\chapter{Pointer}
\hypertarget{md_libraries_2fc_2include_2fc_2crypto_2webauthn__json_2doc_2pointer_8zh-cn}{}\label{md_libraries_2fc_2include_2fc_2crypto_2webauthn__json_2doc_2pointer_8zh-cn}\index{Pointer@{Pointer}}
（本功能于 v1.\+1.\+0 发布）

JSON Pointer 是一个标准化（\href{https://tools.ietf.org/html/rfc6901}{\texttt{ RFC6901}}）的方式去选取一个 JSON Document（\+DOM）中的值。这类似于 XML 的 XPath。然而，\+JSON Pointer 简单得多，而且每个 JSON Pointer 仅指向单个值。

使用 Rapid\+JSON 的 JSON Pointer 实现能简化一些 DOM 的操作。\hypertarget{md_libraries_2fc_2include_2fc_2crypto_2webauthn__json_2doc_2pointer_8zh-cn_JsonPointer}{}\doxysection{\texorpdfstring{JSON Pointer}{JSON Pointer}}\label{md_libraries_2fc_2include_2fc_2crypto_2webauthn__json_2doc_2pointer_8zh-cn_JsonPointer}
一个 JSON Pointer 由一串（零至多个）token 所组成，每个 token 都有 {\ttfamily /} 前缀。每个 token 可以是一个字符串或数字。例如，给定一个 JSON： 
\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ "{}foo"{}\ :\ ["{}bar"{},\ "{}baz"{}],}
\DoxyCodeLine{\ \ \ \ "{}pi"{}\ :\ 3.1416}
\DoxyCodeLine{\}}

\end{DoxyCode}


以下的 JSON Pointer 解析为：


\begin{DoxyEnumerate}
\item {\ttfamily "{}/foo"{}} → {\ttfamily \mbox{[} "{}bar"{}, "{}baz"{} \mbox{]}}
\item {\ttfamily "{}/foo/0"{}} → {\ttfamily "{}bar"{}}
\item {\ttfamily "{}/foo/1"{}} → {\ttfamily "{}baz"{}}
\item {\ttfamily "{}/pi"{}} → {\ttfamily 3.\+1416}
\end{DoxyEnumerate}

要注意，一个空 JSON Pointer {\ttfamily "{}"{}} （零个 token）解析为整个 JSON。\hypertarget{md_libraries_2fc_2include_2fc_2crypto_2webauthn__json_2doc_2schema_8zh-cn_BasicUsage}{}\doxysection{\texorpdfstring{Basic Usage}{Basic Usage}}\label{md_libraries_2fc_2include_2fc_2crypto_2webauthn__json_2doc_2schema_8zh-cn_BasicUsage}
以下的代码范例不解自明。


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ "{}\mbox{\hyperlink{pointer_8h}{rapidjson/pointer.h}}"{}}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ ...}}
\DoxyCodeLine{\mbox{\hyperlink{class_generic_document}{Document}}\ \mbox{\hyperlink{yubihsm__pkcs11_8c_a107648633008a7f2d872b4b3d98c2f96}{d}};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ 使用\ Set()\ 创建\ DOM}}
\DoxyCodeLine{\mbox{\hyperlink{fwd_8h_a0e5c49dba7ec654cdda5735347c00397}{Pointer}}(\textcolor{stringliteral}{"{}/project"{}}).Set(d,\ \textcolor{stringliteral}{"{}RapidJSON"{}});}
\DoxyCodeLine{\mbox{\hyperlink{fwd_8h_a0e5c49dba7ec654cdda5735347c00397}{Pointer}}(\textcolor{stringliteral}{"{}/stars"{}}).Set(d,\ 10);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ \{\ "{}project"{}\ :\ "{}RapidJSON"{},\ "{}stars"{}\ :\ 10\ \}}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ 使用\ Get()\ 访问\ DOM。若该值不存在则返回\ nullptr。}}
\DoxyCodeLine{\textcolor{keywordflow}{if}\ (\mbox{\hyperlink{class_generic_value}{Value}}*\ stars\ =\ \mbox{\hyperlink{fwd_8h_a0e5c49dba7ec654cdda5735347c00397}{Pointer}}(\textcolor{stringliteral}{"{}/stars"{}}).Get(d))}
\DoxyCodeLine{\ \ \ \ stars-\/>SetInt(stars-\/>GetInt()\ +\ 1);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ \{\ "{}project"{}\ :\ "{}RapidJSON"{},\ "{}stars"{}\ :\ 11\ \}}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Set()\ 和\ Create()\ 自动生成父值（如果它们不存在）。}}
\DoxyCodeLine{\mbox{\hyperlink{fwd_8h_a0e5c49dba7ec654cdda5735347c00397}{Pointer}}(\textcolor{stringliteral}{"{}/a/b/0"{}}).Create(d);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ \{\ "{}project"{}\ :\ "{}RapidJSON"{},\ "{}stars"{}\ :\ 11,\ "{}a"{}\ :\ \{\ "{}b"{}\ :\ [\ null\ ]\ \}\ \}}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ GetWithDefault()\ 返回引用。若该值不存在则会深拷贝缺省值。}}
\DoxyCodeLine{\mbox{\hyperlink{class_generic_value}{Value}}\&\ hello\ =\ \mbox{\hyperlink{fwd_8h_a0e5c49dba7ec654cdda5735347c00397}{Pointer}}(\textcolor{stringliteral}{"{}/hello"{}}).GetWithDefault(d,\ \textcolor{stringliteral}{"{}world"{}});}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ \{\ "{}project"{}\ :\ "{}RapidJSON"{},\ "{}stars"{}\ :\ 11,\ "{}a"{}\ :\ \{\ "{}b"{}\ :\ [\ null\ ]\ \},\ "{}hello"{}\ :\ "{}world"{}\ \}}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Swap()\ 和\ Set()\ 相似}}
\DoxyCodeLine{\mbox{\hyperlink{class_generic_value}{Value}}\ x(\textcolor{stringliteral}{"{}C++"{}});}
\DoxyCodeLine{\mbox{\hyperlink{fwd_8h_a0e5c49dba7ec654cdda5735347c00397}{Pointer}}(\textcolor{stringliteral}{"{}/hello"{}}).Swap(d,\ x);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ \{\ "{}project"{}\ :\ "{}RapidJSON"{},\ "{}stars"{}\ :\ 11,\ "{}a"{}\ :\ \{\ "{}b"{}\ :\ [\ null\ ]\ \},\ "{}hello"{}\ :\ "{}C++"{}\ \}}}
\DoxyCodeLine{\textcolor{comment}{//\ x\ 变成\ "{}world"{}}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ 删去一个成员或元素，若值存在返回\ true}}
\DoxyCodeLine{\textcolor{keywordtype}{bool}\ \mbox{\hyperlink{namespacesysio_1_1chain_1_1webassembly_a72ffd6653260a2dedcc4b55e39e10973a4e09c20e9a85794807a130e8283e8769}{success}}\ =\ \mbox{\hyperlink{fwd_8h_a0e5c49dba7ec654cdda5735347c00397}{Pointer}}(\textcolor{stringliteral}{"{}/a"{}}).Erase(d);}
\DoxyCodeLine{assert(success);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ \{\ "{}project"{}\ :\ "{}RapidJSON"{},\ "{}stars"{}\ :\ 10\ \}}}

\end{DoxyCode}
\hypertarget{md_libraries_2fc_2include_2fc_2crypto_2webauthn__json_2doc_2pointer_8zh-cn_HelperFunctions}{}\doxysection{\texorpdfstring{Helper Functions}{Helper Functions}}\label{md_libraries_2fc_2include_2fc_2crypto_2webauthn__json_2doc_2pointer_8zh-cn_HelperFunctions}
由于面向对象的调用习惯可能不符直觉，\+Rapid\+JSON 也提供了一些辅助函数，它们把成员函数包装成自由函数。

以下的例子与上面例子所做的事情完全相同。


\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{class_generic_document}{Document}}\ \mbox{\hyperlink{yubihsm__pkcs11_8c_a107648633008a7f2d872b4b3d98c2f96}{d}};}
\DoxyCodeLine{}
\DoxyCodeLine{\mbox{\hyperlink{pointer_8h_a58128fa07ac8e9159440c83d0a78f2be}{SetValueByPointer}}(d,\ \textcolor{stringliteral}{"{}/project"{}},\ \textcolor{stringliteral}{"{}RapidJSON"{}});}
\DoxyCodeLine{\mbox{\hyperlink{pointer_8h_a58128fa07ac8e9159440c83d0a78f2be}{SetValueByPointer}}(d,\ \textcolor{stringliteral}{"{}/stars"{}},\ 10);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordflow}{if}\ (\mbox{\hyperlink{class_generic_value}{Value}}*\ stars\ =\ \mbox{\hyperlink{pointer_8h_a581633984b11d0587c2ad06649efefc4}{GetValueByPointer}}(d,\ \textcolor{stringliteral}{"{}/stars"{}}))}
\DoxyCodeLine{\ \ \ \ stars-\/>SetInt(stars-\/>GetInt()\ +\ 1);}
\DoxyCodeLine{}
\DoxyCodeLine{\mbox{\hyperlink{pointer_8h_a7ce0d37e372f630e46e221e45714e84b}{CreateValueByPointer}}(d,\ \textcolor{stringliteral}{"{}/a/b/0"{}});}
\DoxyCodeLine{}
\DoxyCodeLine{\mbox{\hyperlink{class_generic_value}{Value}}\&\ hello\ =\ \mbox{\hyperlink{pointer_8h_accdac20f6fea3ab631da1a0df5208a61}{GetValueByPointerWithDefault}}(d,\ \textcolor{stringliteral}{"{}/hello"{}},\ \textcolor{stringliteral}{"{}world"{}});}
\DoxyCodeLine{}
\DoxyCodeLine{\mbox{\hyperlink{class_generic_value}{Value}}\ x(\textcolor{stringliteral}{"{}C++"{}});}
\DoxyCodeLine{\mbox{\hyperlink{pointer_8h_a542981a8bdcf3bc3c701c7eff39648ac}{SwapValueByPointer}}(d,\ \textcolor{stringliteral}{"{}/hello"{}},\ x);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{bool}\ \mbox{\hyperlink{namespacesysio_1_1chain_1_1webassembly_a72ffd6653260a2dedcc4b55e39e10973a4e09c20e9a85794807a130e8283e8769}{success}}\ =\ \mbox{\hyperlink{pointer_8h_a7342710933f35ad7267c871f4a8cc55f}{EraseValueByPointer}}(d,\ \textcolor{stringliteral}{"{}/a"{}});}
\DoxyCodeLine{assert(success);}

\end{DoxyCode}


以下对比 3 种调用方式：


\begin{DoxyEnumerate}
\item {\ttfamily \doxylink{fwd_8h_a0e5c49dba7ec654cdda5735347c00397}{Pointer(source)}.\texorpdfstring{$<$}{<}Method\texorpdfstring{$>$}{>}(root, ...)}
\item {\ttfamily \texorpdfstring{$<$}{<}Method\texorpdfstring{$>$}{>}Value\+By\+Pointer(root, Pointer(source), ...)}
\item {\ttfamily \texorpdfstring{$<$}{<}Method\texorpdfstring{$>$}{>}Value\+By\+Pointer(root, source, ...)}
\end{DoxyEnumerate}\hypertarget{md_libraries_2fc_2include_2fc_2crypto_2webauthn__json_2doc_2pointer_8zh-cn_ResolvingPointer}{}\doxysection{\texorpdfstring{Resolving Pointer}{Resolving Pointer}}\label{md_libraries_2fc_2include_2fc_2crypto_2webauthn__json_2doc_2pointer_8zh-cn_ResolvingPointer}
{\ttfamily Pointer\+::\+Get()} 或 {\ttfamily \doxylink{pointer_8h_a581633984b11d0587c2ad06649efefc4}{Get\+Value\+By\+Pointer()}} 函数并不修改 DOM。若那些 token 不能匹配 DOM 里的值，这些函数便返回 {\ttfamily nullptr}。使用者可利用这个方法来检查一个值是否存在。

注意，数值 token 可表示数组索引或成员名字。解析过程中会按值的类型来匹配。


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ "{}0"{}\ :\ 123,}
\DoxyCodeLine{\ \ \ \ "{}1"{}\ :\ [456]}
\DoxyCodeLine{\}}

\end{DoxyCode}



\begin{DoxyEnumerate}
\item {\ttfamily "{}/0"{}} → {\ttfamily 123}
\item {\ttfamily "{}/1/0"{}} → {\ttfamily 456}
\end{DoxyEnumerate}

Token {\ttfamily "{}0"{}} 在第一个 pointer 中被当作成员名字。它在第二个 pointer 中被当作成数组索引。

其他函数会改变 DOM，包括 {\ttfamily Create()}、{\ttfamily Get\+With\+Default()}、{\ttfamily Set()}、{\ttfamily Swap()}。这些函数总是成功的。若一些父值不存在，就会创建它们。若父值类型不匹配 token，也会强行改变其类型。改变类型也意味着完全移除其 DOM 子树的内容。

例如，把上面的 JSON 解译至 {\ttfamily d} 之后，


\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{pointer_8h_a58128fa07ac8e9159440c83d0a78f2be}{SetValueByPointer}}(d,\ \textcolor{stringliteral}{"{}1/a"{}},\ 789);\ \textcolor{comment}{//\ \{\ "{}0"{}\ :\ 123,\ "{}1"{}\ :\ \{\ "{}a"{}\ :\ 789\ \}\ \}}}

\end{DoxyCode}


\doxysubsection*{解析负号 token}

另外，\href{https://tools.ietf.org/html/rfc6901}{\texttt{ RFC6901}} 定义了一个特殊 token {\ttfamily -\/} （单个负号），用于表示数组最后元素的下一个元素。 {\ttfamily Get()} 只会把此 token 当作成员名字 \textquotesingle{}"{}-\/"{}\textquotesingle{}。而其他函数则会以此解析数组，等同于对数组调用 {\ttfamily Value\+::\+Push\+Back()} 。


\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{class_generic_document}{Document}}\ \mbox{\hyperlink{yubihsm__pkcs11_8c_a107648633008a7f2d872b4b3d98c2f96}{d}};}
\DoxyCodeLine{\mbox{\hyperlink{yubihsm__pkcs11_8c_a107648633008a7f2d872b4b3d98c2f96}{d}}.Parse(\textcolor{stringliteral}{"{}\{\(\backslash\)"{}foo\(\backslash\)"{}:[123]\}"{}});}
\DoxyCodeLine{\mbox{\hyperlink{pointer_8h_a58128fa07ac8e9159440c83d0a78f2be}{SetValueByPointer}}(d,\ \textcolor{stringliteral}{"{}/foo/-\/"{}},\ 456);\ \textcolor{comment}{//\ \{\ "{}foo"{}\ :\ [123,\ 456]\ \}}}
\DoxyCodeLine{\mbox{\hyperlink{pointer_8h_a58128fa07ac8e9159440c83d0a78f2be}{SetValueByPointer}}(d,\ \textcolor{stringliteral}{"{}/-\/"{}},\ 789);\ \ \ \ \textcolor{comment}{//\ \{\ "{}foo"{}\ :\ [123,\ 456],\ "{}-\/"{}\ :\ 789\ \}}}

\end{DoxyCode}


\doxysubsection*{解析 Document 及 Value}

当使用 {\ttfamily p.\+Get(root)} 或 {\ttfamily Get\+Value\+By\+Pointer(root, p)}，{\ttfamily root} 是一个（常数） {\ttfamily Value\&}。这意味着，它也可以是 DOM 里的一个子树。

其他函数有两组签名。一组使用 {\ttfamily Document\& document} 作为参数，另一组使用 {\ttfamily Value\& root}。第一组使用 {\ttfamily document.\+Get\+Allocator()} 去创建值，而第二组则需要使用者提供一个 allocator，如同 DOM 里的函数。

以上例子都不需要 allocator 参数，因为它的第一个参数是 {\ttfamily Document\&}。但如果你需要对一个子树进行解析，就需要如下面的例子般提供 allocator：


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class\ }\mbox{\hyperlink{class_person}{Person}}\ \{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{class_person_a5e10221f201605ad323d5518e5436bd3}{Person}}()\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ document\_\ =\ \textcolor{keyword}{new}\ \mbox{\hyperlink{document_8h_ac6ea5b168e3fe8c7fa532450fc9391f7}{Document}}();}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ CreateValueByPointer()\ here\ no\ need\ allocator}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ SetLocation(\mbox{\hyperlink{pointer_8h_a7ce0d37e372f630e46e221e45714e84b}{CreateValueByPointer}}(*document\_,\ \textcolor{stringliteral}{"{}/residence"{}}),\ ...);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ SetLocation(\mbox{\hyperlink{pointer_8h_a7ce0d37e372f630e46e221e45714e84b}{CreateValueByPointer}}(*document\_,\ \textcolor{stringliteral}{"{}/office"{}}),\ ...);}
\DoxyCodeLine{\ \ \ \ \};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{private}:}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ SetLocation(\mbox{\hyperlink{class_generic_value}{Value}}\&\ location,\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ country,\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ addresses[2])\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ Value::Allocator\&\ \mbox{\hyperlink{pointer_8h_aeeddce917cf130d62c370b8f216026dd}{a}}\ =\ document\_-\/>GetAllocator();}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ SetValueByPointer()\ here\ need\ allocator}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \mbox{\hyperlink{pointer_8h_a58128fa07ac8e9159440c83d0a78f2be}{SetValueByPointer}}(location,\ \textcolor{stringliteral}{"{}/country"{}},\ country,\ \mbox{\hyperlink{pointer_8h_aeeddce917cf130d62c370b8f216026dd}{a}});}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \mbox{\hyperlink{pointer_8h_a58128fa07ac8e9159440c83d0a78f2be}{SetValueByPointer}}(location,\ \textcolor{stringliteral}{"{}/address/0"{}},\ address[0],\ \mbox{\hyperlink{pointer_8h_aeeddce917cf130d62c370b8f216026dd}{a}});}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \mbox{\hyperlink{pointer_8h_a58128fa07ac8e9159440c83d0a78f2be}{SetValueByPointer}}(location,\ \textcolor{stringliteral}{"{}/address/1"{}},\ address[1],\ \mbox{\hyperlink{pointer_8h_aeeddce917cf130d62c370b8f216026dd}{a}});}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ ...}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{class_generic_document}{Document}}*\ document\_;}
\DoxyCodeLine{\};}

\end{DoxyCode}


{\ttfamily Erase()} 或 {\ttfamily \doxylink{pointer_8h_a7342710933f35ad7267c871f4a8cc55f}{Erase\+Value\+By\+Pointer()}} 不需要 allocator。而且它们成功删除值之后会返回 {\ttfamily true}。\hypertarget{md_libraries_2fc_2include_2fc_2crypto_2webauthn__json_2doc_2pointer_8zh-cn_ErrorHandling}{}\doxysection{\texorpdfstring{Error Handling}{Error Handling}}\label{md_libraries_2fc_2include_2fc_2crypto_2webauthn__json_2doc_2pointer_8zh-cn_ErrorHandling}
{\ttfamily Pointer} 在其建构函数里会解译源字符串。若有解析错误，{\ttfamily Pointer\+::\+Is\+Valid()} 返回 {\ttfamily false}。你可使用 {\ttfamily Pointer\+::\+Get\+Parse\+Error\+Code()} 和 {\ttfamily Get\+Parse\+Error\+Offset()} 去获取错信息。

要注意的是，所有解析函数都假设 pointer 是合法的。对一个非法 pointer 解析会造成断言失败。\hypertarget{md_libraries_2fc_2include_2fc_2crypto_2webauthn__json_2doc_2pointer_8zh-cn_URIFragment}{}\doxysection{\texorpdfstring{URI Fragment Representation}{URI Fragment Representation}}\label{md_libraries_2fc_2include_2fc_2crypto_2webauthn__json_2doc_2pointer_8zh-cn_URIFragment}
除了我们一直在使用的字符串方式表示 JSON pointer，\href{https://tools.ietf.org/html/rfc6901}{\texttt{ RFC6901}} 也定义了一个 JSON Pointer 的 URI 片段（fragment）表示方式。\+URI 片段是定义于 \href{https://tools.ietf.org/html/rfc3986}{\texttt{ RFC3986}} "{}\+Uniform Resource Identifier (\+URI)\+: Generic Syntax"{}。

URI 片段的主要分别是必然以 {\ttfamily \#} （pound sign）开头，而一些字符也会以百分比编码成 UTF-\/8 序列。例如，以下的表展示了不同表示法下的 C/\+C++ 字符串常数。

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ 字符串表示方式   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ URI 片段表示方式   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Pointer Tokens （\+UTF-\/8）    }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ 字符串表示方式   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ URI 片段表示方式   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Pointer Tokens （\+UTF-\/8）    }\\\cline{1-3}
\endhead
{\ttfamily "{}/foo/0"{}}   &{\ttfamily "{}\#/foo/0"{}}   &{\ttfamily \{"{}foo"{}, 0\}}    \\\cline{1-3}
{\ttfamily "{}/a\texorpdfstring{$\sim$}{\string~}1b"{}}   &{\ttfamily "{}\#/a\texorpdfstring{$\sim$}{\string~}1b"{}}   &{\ttfamily \{"{}a/b"{}\}}    \\\cline{1-3}
{\ttfamily "{}/m\texorpdfstring{$\sim$}{\string~}0n"{}}   &{\ttfamily "{}\#/m\texorpdfstring{$\sim$}{\string~}0n"{}}   &{\ttfamily \{"{}m\texorpdfstring{$\sim$}{\string~}n"{}\}}    \\\cline{1-3}
{\ttfamily "{}/ "{}}   &{\ttfamily "{}\#/\%20"{}}   &{\ttfamily \{"{} "{}\}}    \\\cline{1-3}
{\ttfamily "{}/\textbackslash{}0"{}}   &{\ttfamily "{}\#/\%00"{}}   &{\ttfamily \{"{}\textbackslash{}0"{}\}}    \\\cline{1-3}
{\ttfamily "{}/€"{}}   &{\ttfamily "{}\#/\%\+E2\%82\%\+AC"{}}   &{\ttfamily \{"{}€"{}\}}   \\\cline{1-3}
\end{longtabu}


Rapid\+JSON 完全支持 URI 片段表示方式。它在解译时会自动检测 {\ttfamily \#} 号。

\doxysection*{字符串化}

你也可以把一个 {\ttfamily Pointer} 字符串化，储存于字符串或其他输出流。例如：


\begin{DoxyCode}{0}
\DoxyCodeLine{Pointer\ p(...);}
\DoxyCodeLine{StringBuffer\ sb;}
\DoxyCodeLine{p.Stringify(sb);}
\DoxyCodeLine{std::cout\ <<\ sb.GetString()\ <<\ std::endl;}

\end{DoxyCode}


使用 {\ttfamily Stringify\+Uri\+Fragment()} 可以把 pointer 字符串化为 URI 片段表示法。\hypertarget{md_libraries_2fc_2include_2fc_2crypto_2webauthn__json_2doc_2pointer_8zh-cn_UserSuppliedTokens}{}\doxysection{\texorpdfstring{User-\/\+Supplied Tokens}{User-\/\+Supplied Tokens}}\label{md_libraries_2fc_2include_2fc_2crypto_2webauthn__json_2doc_2pointer_8zh-cn_UserSuppliedTokens}
若一个 pointer 会用于多次解析，它应该只被创建一次，然后再施于不同的 DOM ，或在不同时间做解析。这样可以避免多次创键 {\ttfamily Pointer}，节省时间和内存分配。

我们甚至可以再更进一步，完全消去解析过程及动态内存分配。我们可以直接生成 token 数组：


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ NAME(s)\ \{\ s,\ sizeof(s)\ /\ sizeof(s[0])\ -\/\ 1,\ kPointerInvalidIndex\ \}}}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ INDEX(i)\ \{\ \#i,\ sizeof(\#i)\ -\/\ 1,\ i\ \}}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \mbox{\hyperlink{struct_generic_pointer_1_1_token}{Pointer::Token}}\ kTokens[]\ =\ \{\ \mbox{\hyperlink{pointertest_8cpp_a59c7737920212dcb3bb9df58d7062de4}{NAME}}(\textcolor{stringliteral}{"{}foo"{}}),\ \mbox{\hyperlink{pointertest_8cpp_aa5fad23b2a5eed790e6661e896a506b7}{INDEX}}(123)\ \};}
\DoxyCodeLine{\textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \mbox{\hyperlink{class_generic_pointer}{Pointer}}\ \mbox{\hyperlink{bn_8cpp_a8b0eadcc506862e9d751ab45185053aa}{p}}(kTokens,\ \textcolor{keyword}{sizeof}(kTokens)\ /\ \textcolor{keyword}{sizeof}(kTokens[0]));}
\DoxyCodeLine{\textcolor{comment}{//\ Equivalent\ to\ static\ const\ Pointer\ p("{}/foo/123"{});}}

\end{DoxyCode}


这种做法可能适合内存受限的系统。 