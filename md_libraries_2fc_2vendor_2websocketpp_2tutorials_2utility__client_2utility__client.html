<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Wire Sysio: Utility Client Example Application Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Wire Sysio<span id="projectnumber">&#160;Wire Sysion 1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_libraries_2fc_2vendor_2websocketpp_2tutorials_2utility__client_2utility__client.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Utility Client Example Application Tutorial</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>Chapter 1: Initial Setup &amp; Basics </h1>
<p>Setting up the basic types, opening and closing connections, sending and receiving messages.</p>
<h2>Step 1</h2>
<p><a class="el" href="struct_a.html">A</a> basic program loop that prompts the user for a command and then processes it. In this tutorial we will modify this program to perform tasks and retrieve data from a remote server over a WebSocket connection.</p>
<h3>Build</h3>
<p><code>clang++ step1.cpp</code></p>
<h3><a class="el" href="struct_code.html">Code</a> so far</h3>
<p><em>note</em> <a class="el" href="struct_a.html">A</a> code snapshot for each step is present next to this tutorial file in the git repository.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="platform__timer__posix__test_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>() {</div>
<div class="line">    <span class="keywordtype">bool</span> done = <span class="keyword">false</span>;</div>
<div class="line">    std::string input;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">while</span> (!done) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Enter Command: &quot;</span>;</div>
<div class="line">        std::getline(std::cin, input);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (input == <span class="stringliteral">&quot;quit&quot;</span>) {</div>
<div class="line">            done = <span class="keyword">true</span>;</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (input == <span class="stringliteral">&quot;help&quot;</span>) {</div>
<div class="line">            std::cout</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;\nCommand List:\n&quot;</span></div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;help: Display this help text\n&quot;</span></div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;quit: Exit the program\n&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Unrecognized Command&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aplatform__timer__posix__test_8c_html_ae66f6b31b5ad750f1fe042a706a4e3d4"><div class="ttname"><a href="platform__timer__posix__test_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a></div><div class="ttdeci">int main()</div><div class="ttdef"><b>Definition</b> <a href="platform__timer__posix__test_8c_source.html#l00005">platform_timer_posix_test.c:5</a></div></div>
</div><!-- fragment --><h2>Step 2</h2>
<p><em>Add WebSocket++ includes and set up an endpoint type.</em></p>
<p>WebSocket++ includes two major object types. The endpoint and the connection. The endpoint creates and launches new connections and maintains default settings for those connections. Endpoints also manage any shared network resources.</p>
<p>The connection stores information specific to each WebSocket session.</p>
<blockquote class="doxtable">
<p>&zwj;<b>Note:</b> Once a connection is launched, there is no link between the endpoint and the connection. All default settings are copied into the new connection by the endpoint. Changing default settings on an endpoint will only affect future connections. Connections do not maintain a link back to their associated endpoint. Endpoints do not maintain a list of outstanding connections. If your application needs to iterate over all connections it will need to maintain a list of them itself. </p>
</blockquote>
<p>WebSocket++ endpoints are built by combining an endpoint role with an endpoint config. There are two different types of endpoint roles, one each for the client and server roles in a WebSocket session. This is a client tutorial so we will use the client role <code><a class="el" href="classwebsocketpp_1_1client.html" title="Client endpoint role based on the given config.">websocketpp::client</a></code> which is provided by the <code>&lt;<a class="el" href="client_8hpp.html">websocketpp/client.hpp</a>&gt;</code> header.</p>
<blockquote class="doxtable">
<p>&zwj;##### Terminology: Endpoint Config WebSocket++ endpoints have a group of settings that may be configured at compile time via the <code>config</code> template parameter. <a class="el" href="struct_a.html">A</a> config is a struct that contains types and static constants that are used to produce an endpoint with specific properties. Depending on which config is being used the endpoint will have different methods available and may have additional third party dependencies. </p>
</blockquote>
<p>The endpoint role takes a template parameter called <code>config</code> that is used to configure the behavior of endpoint at compile time. For this example we are going to use a default config provided by the library called <code>asio_client</code>, provided by <code>&lt;<a class="el" href="asio__no__tls__client_8hpp.html">websocketpp/config/asio_no_tls_client.hpp</a>&gt;</code>. This is a client config that uses <a class="el" href="namespaceboost_1_1asio.html">boost::asio</a> to provide network transport and does not support TLS based security. Later on we will discuss how to introduce TLS based security into a WebSocket++ application, more about the other stock configs, and how to build your own custom configs.</p>
<p>Combine a config with an endpoint role to produce a fully configured endpoint. This type will be used frequently so I would recommend a typedef here.</p>
<p><code>typedef <a class="el" href="classwebsocketpp_1_1client.html" title="Client endpoint role based on the given config.">websocketpp::client</a>&lt;<a class="el" href="structwebsocketpp_1_1config_1_1asio__client.html" title="Client config with asio transport and TLS disabled.">websocketpp::config::asio_client</a>&gt; client</code></p>
<h3>Build</h3>
<p>Adding WebSocket++ has added a few dependencies to our program that must be addressed in the build system. Firstly, the WebSocket++ and Boost library headers must be in the include search path of your build system. How exactly this is done depends on where you have the WebSocket++ headers installed and what build system you are using.</p>
<p>In addition to the new headers, <a class="el" href="namespaceboost_1_1asio.html">boost::asio</a> depends on the <code>boost_system</code> shared library. This will need to be added (either as a static or dynamic) to the linker. Refer to your build environment documentation for instructions on linking to shared libraries.</p>
<p><code>clang++ step2.cpp -lboost_system</code></p>
<h3><a class="el" href="struct_code.html">Code</a> so far</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="asio__no__tls__client_8hpp.html">websocketpp/config/asio_no_tls_client.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="client_8hpp.html">websocketpp/client.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classwebsocketpp_1_1client.html">websocketpp::client&lt;websocketpp::config::asio_client&gt;</a> <a class="code hl_typedef" href="debug__client_8cpp.html#aff8c62b83a9c8aefc476f96166656b76">client</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="platform__timer__posix__test_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>() {</div>
<div class="line">    <span class="keywordtype">bool</span> done = <span class="keyword">false</span>;</div>
<div class="line">    std::string input;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">while</span> (!done) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Enter Command: &quot;</span>;</div>
<div class="line">        std::getline(std::cin, input);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (input == <span class="stringliteral">&quot;quit&quot;</span>) {</div>
<div class="line">            done = <span class="keyword">true</span>;</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (input == <span class="stringliteral">&quot;help&quot;</span>) {</div>
<div class="line">            std::cout</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;\nCommand List:\n&quot;</span></div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;help: Display this help text\n&quot;</span></div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;quit: Exit the program\n&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Unrecognized Command&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aasio__no__tls__client_8hpp_html"><div class="ttname"><a href="asio__no__tls__client_8hpp.html">asio_no_tls_client.hpp</a></div></div>
<div class="ttc" id="aclasswebsocketpp_1_1client_html"><div class="ttname"><a href="classwebsocketpp_1_1client.html">websocketpp::client</a></div><div class="ttdoc">Client endpoint role based on the given config.</div><div class="ttdef"><b>Definition</b> <a href="client__endpoint_8hpp_source.html#l00047">client_endpoint.hpp:47</a></div></div>
<div class="ttc" id="aclient_8hpp_html"><div class="ttname"><a href="client_8hpp.html">client.hpp</a></div></div>
<div class="ttc" id="adebug__client_8cpp_html_aff8c62b83a9c8aefc476f96166656b76"><div class="ttname"><a href="debug__client_8cpp.html#aff8c62b83a9c8aefc476f96166656b76">client</a></div><div class="ttdeci">websocketpp::client&lt; websocketpp::config::asio_client &gt; client</div><div class="ttdef"><b>Definition</b> <a href="debug__client_8cpp_source.html#l00039">debug_client.cpp:39</a></div></div>
</div><!-- fragment --><h2>Step 3</h2>
<p><em>Create endpoint wrapper object that handles initialization and setting up the background thread.</em></p>
<p>In order to process user input while network processing occurs in the background we are going to use a separate thread for the WebSocket++ processing loop. This leaves the main thread free to process foreground user input. In order to enable simple RAII style resource management for our thread and endpoint we will use a wrapper object that configures them both in its constructor.</p>
<blockquote class="doxtable">
<p>&zwj;##### Terminology: <a class="el" href="namespacewebsocketpp_1_1lib.html">websocketpp::lib</a> namespace WebSocket++ is designed to be used with a C++11 standard library. As this is not universally available in popular build systems the Boost libraries may be used as polyfills for the C++11 standard library in C++98 build environments. The <code><a class="el" href="namespacewebsocketpp_1_1lib.html">websocketpp::lib</a></code> namespace is used by the library and its associated examples to abstract away the distinctions between the two. <code>websocketpp::lib::shared_ptr</code> will evaluate to <code>std::shared_ptr</code> in a C++11 environment and <code>boost::shared_ptr</code> otherwise.</p>
<p>This tutorial uses the <code><a class="el" href="namespacewebsocketpp_1_1lib.html">websocketpp::lib</a></code> wrappers because it doesn't know what the build environment of the reader is. For your applications, unless you are interested in similar portability, are free to use the boost or std versions of these types directly.</p>
<p>&gt;[TODO: link to more information about <a class="el" href="namespacewebsocketpp_1_1lib.html">websocketpp::lib</a> namespace and C++11 setup] </p>
</blockquote>
<p>Within the <code><a class="el" href="classwebsocket__endpoint.html">websocket_endpoint</a></code> constructor several things happen:</p>
<p>First, we set the endpoint logging behavior to silent by clearing all of the access and error logging channels. [TODO: link to more information about logging] </p><div class="fragment"><div class="line">m_endpoint.clear_access_channels(<a class="code hl_variable" href="structwebsocketpp_1_1log_1_1alevel.html#a853aa0b8976e53f3181af3bc398d493e">websocketpp::log::alevel::all</a>);</div>
<div class="line">m_endpoint.clear_error_channels(<a class="code hl_variable" href="structwebsocketpp_1_1log_1_1elevel.html#a9b31ff708c221d314f9f4eb3ff2b1ad7">websocketpp::log::elevel::all</a>);</div>
<div class="ttc" id="astructwebsocketpp_1_1log_1_1alevel_html_a853aa0b8976e53f3181af3bc398d493e"><div class="ttname"><a href="structwebsocketpp_1_1log_1_1alevel.html#a853aa0b8976e53f3181af3bc398d493e">websocketpp::log::alevel::all</a></div><div class="ttdeci">static level const all</div><div class="ttdoc">Special aggregate value representing &quot;all levels&quot;.</div><div class="ttdef"><b>Definition</b> <a href="levels_8hpp_source.html#l00152">levels.hpp:152</a></div></div>
<div class="ttc" id="astructwebsocketpp_1_1log_1_1elevel_html_a9b31ff708c221d314f9f4eb3ff2b1ad7"><div class="ttname"><a href="structwebsocketpp_1_1log_1_1elevel.html#a9b31ff708c221d314f9f4eb3ff2b1ad7">websocketpp::log::elevel::all</a></div><div class="ttdeci">static level const all</div><div class="ttdoc">Special aggregate value representing &quot;all levels&quot;.</div><div class="ttdef"><b>Definition</b> <a href="levels_8hpp_source.html#l00080">levels.hpp:80</a></div></div>
</div><!-- fragment --><p>Next, we initialize the transport system underlying the endpoint and set it to perpetual mode. In perpetual mode the endpoint's processing loop will not exit automatically when it has no connections. This is important because we want this endpoint to remain active while our application is running and process requests for new WebSocket connections on demand as we need them. Both of these methods are specific to the asio transport. They will not be necessary or present in endpoints that use a non-asio config. </p><div class="fragment"><div class="line">m_endpoint.init_asio();</div>
<div class="line">m_endpoint.start_perpetual();</div>
</div><!-- fragment --><p>Finally, we launch a thread to run the <code>run</code> method of our client endpoint. While the endpoint is running it will process connection tasks (read and deliver incoming messages, frame and send outgoing messages, etc). Because it is running in perpetual mode, when there are no connections active it will wait for a new connection. </p><div class="fragment"><div class="line">m_thread.reset(<span class="keyword">new</span> websocketpp::lib::thread(&amp;client::run, &amp;m_endpoint));</div>
</div><!-- fragment --><h3>Build</h3>
<p>Now that our client endpoint template is actually instantiated a few more linker dependencies will show up. In particular, WebSocket clients require a cryptographically secure random number generator. WebSocket++ is able to use either <code>boost_random</code> or the C++11 standard library &lt;random&gt; for this purpose. Because this example also uses threads, if we do not have C++11 std::thread available we will need to include <code>boost_thread</code>.</p>
<h4>Clang (C++98 &amp; boost)</h4>
<p><code>clang++ <a class="el" href="step3_8cpp.html">step3.cpp</a> -lboost_system -lboost_random -lboost_thread</code></p>
<h4>Clang (C++11)</h4>
<p><code>clang++ -std=c++0x -stdlib=libc++ <a class="el" href="step3_8cpp.html">step3.cpp</a> -lboost_system -D_WEBSOCKETPP_CPP11_STL_</code></p>
<h4>G++ (C++98 &amp; Boost)</h4>
<p><code>g++ <a class="el" href="step3_8cpp.html">step3.cpp</a> -lboost_system -lboost_random -lboost_thread</code></p>
<h4>G++ v4.6+ (C++11)</h4>
<p><code>g++ -std=c++0x <a class="el" href="step3_8cpp.html">step3.cpp</a> -lboost_system -D_WEBSOCKETPP_CPP11_STL_</code></p>
<h3><a class="el" href="struct_code.html">Code</a> so far</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="asio__no__tls__client_8hpp.html">websocketpp/config/asio_no_tls_client.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="client_8hpp.html">websocketpp/client.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="thread_8hpp.html">websocketpp/common/thread.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fc_2vendor_2websocketpp_2websocketpp_2common_2memory_8hpp.html">websocketpp/common/memory.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classwebsocketpp_1_1client.html">websocketpp::client&lt;websocketpp::config::asio_client&gt;</a> <a class="code hl_typedef" href="debug__client_8cpp.html#aff8c62b83a9c8aefc476f96166656b76">client</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span><a class="code hl_class" href="classwebsocket__endpoint.html">websocket_endpoint</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code hl_function" href="classwebsocket__endpoint.html#a67c36b27ce42577e7bc03e6d746f673c">websocket_endpoint</a> () {</div>
<div class="line">        m_endpoint.<a class="code hl_function" href="classwebsocketpp_1_1endpoint.html#a3fe357b3c6434273a9965eb52902575d">clear_access_channels</a>(<a class="code hl_variable" href="structwebsocketpp_1_1log_1_1alevel.html#a853aa0b8976e53f3181af3bc398d493e">websocketpp::log::alevel::all</a>);</div>
<div class="line">        m_endpoint.<a class="code hl_function" href="classwebsocketpp_1_1endpoint.html#a8cefa4fc37c0df4eb6ed0bcf04bb0da5">clear_error_channels</a>(<a class="code hl_variable" href="structwebsocketpp_1_1log_1_1elevel.html#a9b31ff708c221d314f9f4eb3ff2b1ad7">websocketpp::log::elevel::all</a>);</div>
<div class="line"> </div>
<div class="line">        m_endpoint.init_asio();</div>
<div class="line">        m_endpoint.start_perpetual();</div>
<div class="line"> </div>
<div class="line">        m_thread.reset(<span class="keyword">new</span> websocketpp::lib::thread(&amp;client::run, &amp;m_endpoint));</div>
<div class="line">    }</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <a class="code hl_class" href="classwebsocketpp_1_1client.html">client</a> m_endpoint;</div>
<div class="line">    websocketpp::lib::shared_ptr&lt;websocketpp::lib::thread&gt; m_thread;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="platform__timer__posix__test_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>() {</div>
<div class="line">    <span class="keywordtype">bool</span> done = <span class="keyword">false</span>;</div>
<div class="line">    std::string input;</div>
<div class="line">    <a class="code hl_class" href="classwebsocket__endpoint.html">websocket_endpoint</a> endpoint;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">while</span> (!done) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Enter Command: &quot;</span>;</div>
<div class="line">        std::getline(std::cin, input);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (input == <span class="stringliteral">&quot;quit&quot;</span>) {</div>
<div class="line">            done = <span class="keyword">true</span>;</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (input == <span class="stringliteral">&quot;help&quot;</span>) {</div>
<div class="line">            std::cout</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;\nCommand List:\n&quot;</span></div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;help: Display this help text\n&quot;</span></div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;quit: Exit the program\n&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Unrecognized Command&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclasswebsocket__endpoint_html"><div class="ttname"><a href="classwebsocket__endpoint.html">websocket_endpoint</a></div><div class="ttdef"><b>Definition</b> <a href="scratch__client_8cpp_source.html#l00113">scratch_client.cpp:113</a></div></div>
<div class="ttc" id="aclasswebsocket__endpoint_html_a67c36b27ce42577e7bc03e6d746f673c"><div class="ttname"><a href="classwebsocket__endpoint.html#a67c36b27ce42577e7bc03e6d746f673c">websocket_endpoint::websocket_endpoint</a></div><div class="ttdeci">websocket_endpoint()</div><div class="ttdef"><b>Definition</b> <a href="scratch__client_8cpp_source.html#l00115">scratch_client.cpp:115</a></div></div>
<div class="ttc" id="aclasswebsocketpp_1_1endpoint_html_a3fe357b3c6434273a9965eb52902575d"><div class="ttname"><a href="classwebsocketpp_1_1endpoint.html#a3fe357b3c6434273a9965eb52902575d">websocketpp::endpoint::clear_access_channels</a></div><div class="ttdeci">void clear_access_channels(log::level channels)</div><div class="ttdoc">Clear Access logging channels.</div><div class="ttdef"><b>Definition</b> <a href="endpoint_8hpp_source.html#l00231">endpoint.hpp:231</a></div></div>
<div class="ttc" id="aclasswebsocketpp_1_1endpoint_html_a8cefa4fc37c0df4eb6ed0bcf04bb0da5"><div class="ttname"><a href="classwebsocketpp_1_1endpoint.html#a8cefa4fc37c0df4eb6ed0bcf04bb0da5">websocketpp::endpoint::clear_error_channels</a></div><div class="ttdeci">void clear_error_channels(log::level channels)</div><div class="ttdoc">Clear Error logging channels.</div><div class="ttdef"><b>Definition</b> <a href="endpoint_8hpp_source.html#l00253">endpoint.hpp:253</a></div></div>
<div class="ttc" id="afc_2vendor_2websocketpp_2websocketpp_2common_2memory_8hpp_html"><div class="ttname"><a href="fc_2vendor_2websocketpp_2websocketpp_2common_2memory_8hpp.html">memory.hpp</a></div></div>
<div class="ttc" id="athread_8hpp_html"><div class="ttname"><a href="thread_8hpp.html">thread.hpp</a></div></div>
</div><!-- fragment --><h2>Step 4</h2>
<p><em>Opening WebSocket connections</em></p>
<p>This step adds two new commands to utility_client. The ability to open a new connection and the ability to view information about a previously opened connection. Every connection that gets opened will be assigned an integer connection id that the user of the program can use to interact with that connection.</p>
<h3>New Connection Metadata Object</h3>
<p>In order to track information about each connection a <code><a class="el" href="classconnection__metadata.html">connection_metadata</a></code> object is defined. This object stores the numeric connection id and a number of fields that will be filled in as the connection is processed. Initially this includes the state of the connection (opening, open, failed, closed, etc), the original URI connected to, an identifying value from the server, and a description of the reason for connection failure/closure. Future steps will add more information to this metadata object.</p>
<h3>Update <code><a class="el" href="classwebsocket__endpoint.html">websocket_endpoint</a></code></h3>
<p>The <code><a class="el" href="classwebsocket__endpoint.html">websocket_endpoint</a></code> object has gained some new data members and methods. It now tracks a mapping between connection IDs and their associated metadata as well as the next sequential ID number to hand out. The <code>connect()</code> method initiates a new connection. The <code>get_metadata</code> method retrieves metadata given an ID.</p>
<h3>The connect method</h3>
<p><a class="el" href="struct_a.html">A</a> new WebSocket connection is initiated via a three step process. First, a connection request is created by <code>endpoint::get_connection(uri)</code>. Next, the connection request is configured. Lastly, the connection request is submitted back to the endpoint via <code>endpoint::connect()</code> which adds it to the queue of new connections to make.</p>
<blockquote class="doxtable">
<p>&zwj;##### Terminology <code>connection_ptr</code> WebSocket++ keeps track of connection related resources using a reference counted shared pointer. The type of this pointer is <code>endpoint::connection_ptr</code>. <a class="el" href="struct_a.html">A</a> <code>connection_ptr</code> allows direct access to information about the connection and allows changing connection settings. Because of this direct access and their internal resource management role within the library it is not safe for end applications to use <code>connection_ptr</code> except in the specific circumstances detailed below.</p>
<p><b>When is it safe to use <code>connection_ptr</code>?</b></p><ul>
<li>After <code>endpoint::get_connection(...)</code> and before <code>endpoint::connect()</code>: <code>get_connection</code> returns a <code>connection_ptr</code>. It is safe to use this pointer to configure your new connection. Once you submit the connection to <code>connect</code> you may no longer use the <code>connection_ptr</code> and should discard it immediately for optimal memory management.</li>
<li>During a handler: WebSocket++ allows you to register hooks / callbacks / event handlers for specific events that happen during a connection's lifetime. During the invocation of one of these handlers the library guarantees that it is safe to use a <code>connection_ptr</code> for the connection associated with the currently running handler. </li>
</ul>
</blockquote>
<blockquote class="doxtable">
<p>&zwj;##### Terminology <code>connection_hdl</code> Because of the limited thread safety of the <code>connection_ptr</code> the library also provides a more flexible connection identifier, the <code>connection_hdl</code>. The <code>connection_hdl</code> has type <code><a class="el" href="namespacewebsocketpp.html#a6b3d26a10ee7229b84b776786332631d" title="A handle to uniquely identify a connection.">websocketpp::connection_hdl</a></code> and it is defined in <code>&lt;<a class="el" href="connection__hdl_8hpp.html">websocketpp/common/connection_hdl.hpp</a>&gt;</code>. Note that unlike <code>connection_ptr</code> this is not dependent on the type or config of the endpoint. <a class="el" href="struct_code.html">Code</a> that simply stores or transmits <code>connection_hdl</code> but does not use them can include only the header above and can treat its hdls like values.</p>
<p>Connection handles are not used directly. They are used by endpoint methods to identify the target of the desired action. For example, the endpoint method that sends a new message will take as a parameter the hdl of the connection to send the message to.</p>
<p><b>When is it safe to use <code>connection_hdl</code>?</b> <code>connection_hdl</code>s may be used at any time from any thread. They may be copied and stored in containers. Deleting a hdl will not affect the connection in any way. Handles may be upgraded to a <code>connection_ptr</code> during a handler call by using <code>endpoint::get_con_from_hdl()</code>. The resulting <code>connection_ptr</code> is safe to use for the duration of that handler invocation.</p>
<p><b><code>connection_hdl</code> FAQs</b></p><ul>
<li><code>connection_hdl</code>s are guaranteed to be unique within a program. Multiple endpoints in a single program will always create connections with unique handles.</li>
<li>Using a <code>connection_hdl</code> with a different endpoint than the one that created its associated connection will result in undefined behavior.</li>
<li>Using a <code>connection_hdl</code> whose associated connection has been closed or deleted is safe. The endpoint will return a specific error saying the operation couldn't be completed because the associated connection doesn't exist. [TODO: more here? link to a connection_hdl FAQ elsewhere?] </li>
</ul>
</blockquote>
<p><code><a class="el" href="classwebsocket__endpoint.html#a5850523b829e145793d42e137d5eb8c0">websocket_endpoint::connect()</a></code> begins by calling <code>endpoint::get_connection()</code> using a uri passed as a parameter. Additionally, an error output value is passed to capture any errors that might occur during. If an error does occur an error notice is printed along with a descriptive message and the -1 / 'invalid' value is returned as the new ID.</p>
<blockquote class="doxtable">
<p>&zwj;###### Terminology: <code>error handling: exceptions vs error_code</code> WebSocket++ uses the error code system defined by the C++11 <code>&lt;system_error&gt;</code> library. It can optionally fall back to a similar system provided by the Boost libraries. All user facing endpoint methods that can fail take an <code>error_code</code> in an output parameter and store the error that occured there before returning. An empty/default constructed value is returned in the case of success.</p>
<p><b>Exception throwing varients</b> All user facing endpoint methods that take and use an <code>error_code</code> parameter have a version that throws an exception instead. These methods are identical in function and signature except for the lack of the final ec parameter. The type of the exception thrown is <code><a class="el" href="classwebsocketpp_1_1exception.html">websocketpp::exception</a></code>. This type derives from <code>std::exception</code> so it can be caught by catch blocks grabbing generic <code>std::exception</code>s. The <code><a class="el" href="classwebsocketpp_1_1exception.html#a2ca743bae5d6ba2be63d1a64bc2f878f">websocketpp::exception::code()</a></code> method may be used to extract the machine readable <code>error_code</code> value from an exception.</p>
<p>For clarity about error handling the utility_client example uses exclusively the exception free varients of these methods. Your application may choose to use either. </p>
</blockquote>
<p>If connection creation succeeds, the next sequential connection ID is generated and a <code><a class="el" href="classconnection__metadata.html">connection_metadata</a></code> object is inserted into the connection list under that ID. Initially the metadata object stores the connection ID, the <code>connection_hdl</code>, and the URI the connection was opened to.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> new_id = m_next_id++;</div>
<div class="line">metadata_ptr metadata(<span class="keyword">new</span> <a class="code hl_class" href="classconnection__metadata.html">connection_metadata</a>(new_id, con-&gt;get_handle(), uri));</div>
<div class="line">m_connection_list[new_id] = metadata;</div>
<div class="ttc" id="aclassconnection__metadata_html"><div class="ttname"><a href="classconnection__metadata.html">connection_metadata</a></div><div class="ttdef"><b>Definition</b> <a href="scratch__client_8cpp_source.html#l00045">scratch_client.cpp:45</a></div></div>
</div><!-- fragment --><p>Next, the connection request is configured. For this step the only configuration we will do is setting up a few default handlers. Later on we will return and demonstrate some more detailed configuration that can happen here (setting user agents, origin, proxies, custom headers, subprotocols, etc).</p>
<blockquote class="doxtable">
<p>&zwj;##### Terminology: Registering handlers WebSocket++ provides a number of execution points where you can register to have a handler run. Which of these points are available to your endpoint will depend on its config. TLS handlers will not exist on non-TLS endpoints for example. <a class="el" href="struct_a.html">A</a> complete list of handlers can be found at <a href="http://www.zaphoyd.com/websocketpp/manual/reference/handler-list">http://www.zaphoyd.com/websocketpp/manual/reference/handler-list</a>.</p>
<p>Handlers can be registered at the endpoint level and at the connection level. Endpoint handlers are copied into new connections as they are created. Changing an endpoint handler will affect only future connections. Handlers registered at the connection level will be bound to that specific connection only.</p>
<p>The signature of handler binding methods is the same for endpoints and connections. The format is: <code>set_*_handler(...)</code>. Where * is the name of the handler. For example, <code>set_open_handler(...)</code> will set the handler to be called when a new connection is open. <code>set_fail_handler(...)</code> will set the handler to be called when a connection fails to connect.</p>
<p>All handlers take one argument, a callable type that can be converted to a <code>std::function</code> with the correct count and type of arguments. You can pass free functions, functors, and Lambdas with matching argument lists as handlers. In addition, you can use <code>std::bind</code> (or <code>boost::bind</code>) to register functions with non-matching argument lists. This is useful for passing additional parameters not present in the handler signature or member functions that need to carry a 'this' pointer.</p>
<p>The function signature of each handler can be looked up in the list above in the manual. In general, all handlers include the <code>connection_hdl</code> identifying which connection this even is associated with as the first parameter. Some handlers (such as the message handler) include additional parameters. Most handlers have a void return value but some (<code>validate</code>, <code>ping</code>, <code>tls_init</code>) do not. The specific meanings of the return values are documented in the handler list linked above. </p>
</blockquote>
<p><code>utility_client</code> registers an open and a fail handler. We will use these to track whether each connection was successfully opened or failed. If it successfully opens, we will gather some information from the opening handshake and store it with our connection metadata.</p>
<p>In this example we are going to set connection specific handlers that are bound directly to the metadata object associated with our connection. This allows us to avoid performing a lookup in each handler to find the metadata object we plan to update which is a bit more efficient.</p>
<p>Lets look at the parameters being sent to bind in detail:</p>
<div class="fragment"><div class="line">con-&gt;set_open_handler(websocketpp::lib::bind(</div>
<div class="line">    &amp;<a class="code hl_function" href="classconnection__metadata.html#ab10d997bd75d9e98b235b7e97b84b85a">connection_metadata::on_open</a>,</div>
<div class="line">    metadata,</div>
<div class="line">    &amp;m_endpoint,</div>
<div class="line">    websocketpp::lib::placeholders::_1</div>
<div class="line">));</div>
<div class="ttc" id="aclassconnection__metadata_html_ab10d997bd75d9e98b235b7e97b84b85a"><div class="ttname"><a href="classconnection__metadata.html#ab10d997bd75d9e98b235b7e97b84b85a">connection_metadata::on_open</a></div><div class="ttdeci">void on_open(client *c, websocketpp::connection_hdl hdl)</div><div class="ttdef"><b>Definition</b> <a href="scratch__client_8cpp_source.html#l00057">scratch_client.cpp:57</a></div></div>
</div><!-- fragment --><p><code>&amp;<a class="el" href="classconnection__metadata.html#ab10d997bd75d9e98b235b7e97b84b85a">connection_metadata::on_open</a></code> is the address of the <code>on_open</code> member function of the <code><a class="el" href="classconnection__metadata.html">connection_metadata</a></code> class. <code>metadata_ptr</code> is a pointer to the <code><a class="el" href="classconnection__metadata.html">connection_metadata</a></code> object associated with this class. It will be used as the object on which the <code>on_open</code> member function will be called. <code>&amp;m_endpoint</code> is the address of the endpoint in use. This parameter will be passed as-is to the <code>on_open</code> method. Lastly, <code>websocketpp::lib::placeholders::_1</code> is a placeholder indicating that the bound function should take one additional argument to be filled in at a later time. WebSocket++ will fill in this placeholder with the <code>connection_hdl</code> when it invokes the handler.</p>
<p>Finally, we call <code>endpoint::connect()</code> on our configured connection request and return the new connection ID.</p>
<h3>Handler Member Functions</h3>
<p>The open handler we registered, <code><a class="el" href="classconnection__metadata.html#ab10d997bd75d9e98b235b7e97b84b85a">connection_metadata::on_open</a></code>, sets the status metadata field to "Open" and retrieves the value of the "Server" header from the remote endpoint's HTTP response and stores it in the metadata object. Servers often set an identifying string in this header.</p>
<p>The fail handler we registered, <code><a class="el" href="classconnection__metadata.html#a1c2e652001b8306207beafe17b1a52ed">connection_metadata::on_fail</a></code>, sets the status metadata field to "Failed", the server field similarly to <code>on_open</code>, and retrieves the error code describing why the connection failed. The human readable message associated with that error code is saved to the metadata object.</p>
<h3>New Commands</h3>
<p>Two new commands have been set up. "connect [uri]" will pass the URI to the <code><a class="el" href="classwebsocket__endpoint.html">websocket_endpoint</a></code> connect method and report an error or the connection ID of the new connection. "show [connection id]" will retrieve and print out the metadata associated with that connection. The help text has been updated accordingly.</p>
<div class="fragment"><div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">if</span> (input.substr(0,7) == <span class="stringliteral">&quot;connect&quot;</span>) {</div>
<div class="line">    <span class="keywordtype">int</span> <span class="keywordtype">id</span> = endpoint.<a class="code hl_function" href="classwebsocket__endpoint.html#a5850523b829e145793d42e137d5eb8c0">connect</a>(input.substr(8));</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keywordtype">id</span> != -1) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;&gt; Created connection with id &quot;</span> &lt;&lt; <span class="keywordtype">id</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">if</span> (input.substr(0,4) == <span class="stringliteral">&quot;show&quot;</span>) {</div>
<div class="line">    <span class="keywordtype">int</span> <span class="keywordtype">id</span> = atoi(input.substr(5).c_str());</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_typedef" href="classconnection__metadata.html#ada3ee69cbbc88df3cc5a74e8840671ac">connection_metadata::ptr</a> metadata = endpoint.<a class="code hl_function" href="classwebsocket__endpoint.html#a5896c27213953d2d33b88e117b1971f6">get_metadata</a>(<span class="keywordtype">id</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (metadata) {</div>
<div class="line">        std::cout &lt;&lt; *metadata &lt;&lt; std::endl;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;&gt; Unknown connection id &quot;</span> &lt;&lt; <span class="keywordtype">id</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclassconnection__metadata_html_ada3ee69cbbc88df3cc5a74e8840671ac"><div class="ttname"><a href="classconnection__metadata.html#ada3ee69cbbc88df3cc5a74e8840671ac">connection_metadata::ptr</a></div><div class="ttdeci">websocketpp::lib::shared_ptr&lt; connection_metadata &gt; ptr</div><div class="ttdef"><b>Definition</b> <a href="scratch__client_8cpp_source.html#l00047">scratch_client.cpp:47</a></div></div>
<div class="ttc" id="aclasswebsocket__endpoint_html_a5850523b829e145793d42e137d5eb8c0"><div class="ttname"><a href="classwebsocket__endpoint.html#a5850523b829e145793d42e137d5eb8c0">websocket_endpoint::connect</a></div><div class="ttdeci">int connect(std::string const &amp;uri)</div><div class="ttdef"><b>Definition</b> <a href="scratch__client_8cpp_source.html#l00147">scratch_client.cpp:147</a></div></div>
<div class="ttc" id="aclasswebsocket__endpoint_html_a5896c27213953d2d33b88e117b1971f6"><div class="ttname"><a href="classwebsocket__endpoint.html#a5896c27213953d2d33b88e117b1971f6">websocket_endpoint::get_metadata</a></div><div class="ttdeci">connection_metadata::ptr get_metadata(int id) const</div><div class="ttdef"><b>Definition</b> <a href="scratch__client_8cpp_source.html#l00200">scratch_client.cpp:200</a></div></div>
</div><!-- fragment --><h3>Build</h3>
<p>There are no changes to the build instructions from step 3</p>
<h3>Run</h3>
<div class="fragment"><div class="line">Enter Command: connect not a websocket uri</div>
<div class="line">&gt; Connect initialization error: invalid uri</div>
<div class="line">Enter Command: show 0</div>
<div class="line">&gt; Unknown connection id 0</div>
<div class="line">Enter Command: connect ws://echo.websocket.org</div>
<div class="line">&gt; Created connection with id 0</div>
<div class="line">Enter Command: show 0</div>
<div class="line">&gt; URI: ws://echo.websocket.org</div>
<div class="line">&gt; Status: Open</div>
<div class="line">&gt; Remote Server: Kaazing Gateway</div>
<div class="line">&gt; Error/close reason: N/A</div>
<div class="line">Enter Command: connect ws://wikipedia.org</div>
<div class="line">&gt; Created connection with id 1</div>
<div class="line">Enter Command: show 1</div>
<div class="line">&gt; URI: ws://wikipedia.org</div>
<div class="line">&gt; Status: Failed</div>
<div class="line">&gt; Remote Server: Apache</div>
<div class="line">&gt; Error/close reason: Invalid HTTP status.</div>
</div><!-- fragment --><h3><a class="el" href="struct_code.html">Code</a> so far</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="asio__no__tls__client_8hpp.html">websocketpp/config/asio_no_tls_client.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="client_8hpp.html">websocketpp/client.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="thread_8hpp.html">websocketpp/common/thread.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fc_2vendor_2websocketpp_2websocketpp_2common_2memory_8hpp.html">websocketpp/common/memory.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classwebsocketpp_1_1client.html">websocketpp::client&lt;websocketpp::config::asio_client&gt;</a> <a class="code hl_typedef" href="debug__client_8cpp.html#aff8c62b83a9c8aefc476f96166656b76">client</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span><a class="code hl_class" href="classconnection__metadata.html">connection_metadata</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">typedef</span> websocketpp::lib::shared_ptr&lt;connection_metadata&gt; <a class="code hl_typedef" href="classconnection__metadata.html#ada3ee69cbbc88df3cc5a74e8840671ac">ptr</a>;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="classconnection__metadata.html#ab73db2e336676ec4efa4d4dc5051958f">connection_metadata</a>(<span class="keywordtype">int</span> <span class="keywordtype">id</span>, <a class="code hl_typedef" href="namespacewebsocketpp.html#a6b3d26a10ee7229b84b776786332631d">websocketpp::connection_hdl</a> hdl, std::string uri)</div>
<div class="line">      : m_id(<a class="code hl_variable" href="code__cache_8cpp.html#aa0efefe21f4700d78692edc823e763be">id</a>)</div>
<div class="line">      , m_hdl(hdl)</div>
<div class="line">      , m_status(<span class="stringliteral">&quot;Connecting&quot;</span>)</div>
<div class="line">      , m_uri(uri)</div>
<div class="line">      , m_server(<span class="stringliteral">&quot;N/A&quot;</span>)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="classconnection__metadata.html#ab10d997bd75d9e98b235b7e97b84b85a">on_open</a>(<a class="code hl_class" href="classwebsocketpp_1_1client.html">client</a> * c, <a class="code hl_typedef" href="namespacewebsocketpp.html#a6b3d26a10ee7229b84b776786332631d">websocketpp::connection_hdl</a> hdl) {</div>
<div class="line">        m_status = <span class="stringliteral">&quot;Open&quot;</span>;</div>
<div class="line"> </div>
<div class="line">        <a class="code hl_typedef" href="classwebsocketpp_1_1client.html#ad9e541a43023d33d5cd5669d62a13edc">client::connection_ptr</a> con = c-&gt;<a class="code hl_function" href="classwebsocketpp_1_1endpoint.html#a0fe4457427d4124abe7ca022ba7afbb4">get_con_from_hdl</a>(hdl);</div>
<div class="line">        m_server = con-&gt;get_response_header(<span class="stringliteral">&quot;Server&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="classconnection__metadata.html#a1c2e652001b8306207beafe17b1a52ed">on_fail</a>(<a class="code hl_class" href="classwebsocketpp_1_1client.html">client</a> * c, <a class="code hl_typedef" href="namespacewebsocketpp.html#a6b3d26a10ee7229b84b776786332631d">websocketpp::connection_hdl</a> hdl) {</div>
<div class="line">        m_status = <span class="stringliteral">&quot;Failed&quot;</span>;</div>
<div class="line"> </div>
<div class="line">        <a class="code hl_typedef" href="classwebsocketpp_1_1client.html#ad9e541a43023d33d5cd5669d62a13edc">client::connection_ptr</a> con = c-&gt;<a class="code hl_function" href="classwebsocketpp_1_1endpoint.html#a0fe4457427d4124abe7ca022ba7afbb4">get_con_from_hdl</a>(hdl);</div>
<div class="line">        m_server = con-&gt;get_response_header(<span class="stringliteral">&quot;Server&quot;</span>);</div>
<div class="line">        m_error_reason = con-&gt;get_ec().message();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">friend</span> std::ostream &amp; <a class="code hl_friend" href="classconnection__metadata.html#a2aec4aeb2bb18764b4be4e1cfb033fb6">operator&lt;&lt; </a>(std::ostream &amp; out, <a class="code hl_class" href="classconnection__metadata.html">connection_metadata</a> <span class="keyword">const</span> &amp; data);</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">int</span> m_id;</div>
<div class="line">    <a class="code hl_typedef" href="namespacewebsocketpp.html#a6b3d26a10ee7229b84b776786332631d">websocketpp::connection_hdl</a> m_hdl;</div>
<div class="line">    std::string m_status;</div>
<div class="line">    std::string m_uri;</div>
<div class="line">    std::string m_server;</div>
<div class="line">    std::string m_error_reason;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">std::ostream &amp; <a class="code hl_function" href="database__utils_8hpp.html#a9c651062fd345156256e69573165086c">operator&lt;&lt; </a>(std::ostream &amp; out, <a class="code hl_class" href="classconnection__metadata.html">connection_metadata</a> <span class="keyword">const</span> &amp; data) {</div>
<div class="line">    out &lt;&lt; <span class="stringliteral">&quot;&gt; URI: &quot;</span> &lt;&lt; data.m_uri &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;&gt; Status: &quot;</span> &lt;&lt; data.m_status &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;&gt; Remote Server: &quot;</span> &lt;&lt; (data.m_server.empty() ? <span class="stringliteral">&quot;None Specified&quot;</span> : data.m_server) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;&gt; Error/close reason: &quot;</span> &lt;&lt; (data.m_error_reason.empty() ? <span class="stringliteral">&quot;N/A&quot;</span> : data.m_error_reason);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span><a class="code hl_class" href="classwebsocket__endpoint.html">websocket_endpoint</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code hl_function" href="classwebsocket__endpoint.html#a67c36b27ce42577e7bc03e6d746f673c">websocket_endpoint</a> () : m_next_id(0) {</div>
<div class="line">        m_endpoint.<a class="code hl_function" href="classwebsocketpp_1_1endpoint.html#a3fe357b3c6434273a9965eb52902575d">clear_access_channels</a>(<a class="code hl_variable" href="structwebsocketpp_1_1log_1_1alevel.html#a853aa0b8976e53f3181af3bc398d493e">websocketpp::log::alevel::all</a>);</div>
<div class="line">        m_endpoint.<a class="code hl_function" href="classwebsocketpp_1_1endpoint.html#a8cefa4fc37c0df4eb6ed0bcf04bb0da5">clear_error_channels</a>(<a class="code hl_variable" href="structwebsocketpp_1_1log_1_1elevel.html#a9b31ff708c221d314f9f4eb3ff2b1ad7">websocketpp::log::elevel::all</a>);</div>
<div class="line"> </div>
<div class="line">        m_endpoint.init_asio();</div>
<div class="line">        m_endpoint.start_perpetual();</div>
<div class="line"> </div>
<div class="line">        m_thread.reset(<span class="keyword">new</span> websocketpp::lib::thread(&amp;client::run, &amp;m_endpoint));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> <a class="code hl_function" href="classwebsocket__endpoint.html#a5850523b829e145793d42e137d5eb8c0">connect</a>(std::string <span class="keyword">const</span> &amp; uri) {</div>
<div class="line">        websocketpp::lib::error_code ec;</div>
<div class="line"> </div>
<div class="line">        <a class="code hl_typedef" href="classwebsocketpp_1_1client.html#ad9e541a43023d33d5cd5669d62a13edc">client::connection_ptr</a> con = m_endpoint.<a class="code hl_function" href="classwebsocketpp_1_1client.html#aa95cec974921e32bc37a61c683ae240d">get_connection</a>(uri, ec);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (ec) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;&gt; Connect initialization error: &quot;</span> &lt;&lt; ec.message() &lt;&lt; std::endl;</div>
<div class="line">            <span class="keywordflow">return</span> -1;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">int</span> new_id = m_next_id++;</div>
<div class="line">        <a class="code hl_typedef" href="classconnection__metadata.html#ada3ee69cbbc88df3cc5a74e8840671ac">connection_metadata::ptr</a> metadata_ptr(<span class="keyword">new</span> <a class="code hl_class" href="classconnection__metadata.html">connection_metadata</a>(new_id, con-&gt;get_handle(), uri));</div>
<div class="line">        m_connection_list[new_id] = metadata_ptr;</div>
<div class="line"> </div>
<div class="line">        con-&gt;set_open_handler(websocketpp::lib::bind(</div>
<div class="line">            &amp;<a class="code hl_function" href="classconnection__metadata.html#ab10d997bd75d9e98b235b7e97b84b85a">connection_metadata::on_open</a>,</div>
<div class="line">            metadata_ptr,</div>
<div class="line">            &amp;m_endpoint,</div>
<div class="line">            websocketpp::lib::placeholders::_1</div>
<div class="line">        ));</div>
<div class="line">        con-&gt;set_fail_handler(websocketpp::lib::bind(</div>
<div class="line">            &amp;<a class="code hl_function" href="classconnection__metadata.html#a1c2e652001b8306207beafe17b1a52ed">connection_metadata::on_fail</a>,</div>
<div class="line">            metadata_ptr,</div>
<div class="line">            &amp;m_endpoint,</div>
<div class="line">            websocketpp::lib::placeholders::_1</div>
<div class="line">        ));</div>
<div class="line"> </div>
<div class="line">        m_endpoint.<a class="code hl_function" href="classwebsocketpp_1_1client.html#a818c30343180123bf1fee6dc21524bae">connect</a>(con);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span> new_id;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_typedef" href="classconnection__metadata.html#ada3ee69cbbc88df3cc5a74e8840671ac">connection_metadata::ptr</a> <a class="code hl_function" href="classwebsocket__endpoint.html#a5896c27213953d2d33b88e117b1971f6">get_metadata</a>(<span class="keywordtype">int</span> <span class="keywordtype">id</span>)<span class="keyword"> const </span>{</div>
<div class="line">        con_list::const_iterator metadata_it = m_connection_list.find(<span class="keywordtype">id</span>);</div>
<div class="line">        <span class="keywordflow">if</span> (metadata_it == m_connection_list.end()) {</div>
<div class="line">            <span class="keywordflow">return</span> <a class="code hl_typedef" href="classconnection__metadata.html#ada3ee69cbbc88df3cc5a74e8840671ac">connection_metadata::ptr</a>();</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="keywordflow">return</span> metadata_it-&gt;second;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">typedef</span> std::map&lt;int,connection_metadata::ptr&gt; con_list;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classwebsocketpp_1_1client.html">client</a> m_endpoint;</div>
<div class="line">    websocketpp::lib::shared_ptr&lt;websocketpp::lib::thread&gt; m_thread;</div>
<div class="line"> </div>
<div class="line">    con_list m_connection_list;</div>
<div class="line">    <span class="keywordtype">int</span> m_next_id;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="platform__timer__posix__test_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>() {</div>
<div class="line">    <span class="keywordtype">bool</span> done = <span class="keyword">false</span>;</div>
<div class="line">    std::string input;</div>
<div class="line">    <a class="code hl_class" href="classwebsocket__endpoint.html">websocket_endpoint</a> endpoint;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">while</span> (!done) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Enter Command: &quot;</span>;</div>
<div class="line">        std::getline(std::cin, input);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (input == <span class="stringliteral">&quot;quit&quot;</span>) {</div>
<div class="line">            done = <span class="keyword">true</span>;</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (input == <span class="stringliteral">&quot;help&quot;</span>) {</div>
<div class="line">            std::cout</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;\nCommand List:\n&quot;</span></div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;connect &lt;ws uri&gt;\n&quot;</span></div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;show &lt;connection id&gt;\n&quot;</span></div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;help: Display this help text\n&quot;</span></div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;quit: Exit the program\n&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (input.substr(0,7) == <span class="stringliteral">&quot;connect&quot;</span>) {</div>
<div class="line">            <span class="keywordtype">int</span> <span class="keywordtype">id</span> = endpoint.<a class="code hl_function" href="classwebsocket__endpoint.html#a5850523b829e145793d42e137d5eb8c0">connect</a>(input.substr(8));</div>
<div class="line">            <span class="keywordflow">if</span> (<span class="keywordtype">id</span> != -1) {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;&gt; Created connection with id &quot;</span> &lt;&lt; <span class="keywordtype">id</span> &lt;&lt; std::endl;</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (input.substr(0,4) == <span class="stringliteral">&quot;show&quot;</span>) {</div>
<div class="line">            <span class="keywordtype">int</span> <span class="keywordtype">id</span> = atoi(input.substr(5).c_str());</div>
<div class="line"> </div>
<div class="line">            <a class="code hl_typedef" href="classconnection__metadata.html#ada3ee69cbbc88df3cc5a74e8840671ac">connection_metadata::ptr</a> metadata = endpoint.<a class="code hl_function" href="classwebsocket__endpoint.html#a5896c27213953d2d33b88e117b1971f6">get_metadata</a>(<span class="keywordtype">id</span>);</div>
<div class="line">            <span class="keywordflow">if</span> (metadata) {</div>
<div class="line">                std::cout &lt;&lt; *metadata &lt;&lt; std::endl;</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;&gt; Unknown connection id &quot;</span> &lt;&lt; <span class="keywordtype">id</span> &lt;&lt; std::endl;</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;&gt; Unrecognized Command&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassconnection__metadata_html_a1c2e652001b8306207beafe17b1a52ed"><div class="ttname"><a href="classconnection__metadata.html#a1c2e652001b8306207beafe17b1a52ed">connection_metadata::on_fail</a></div><div class="ttdeci">void on_fail(client *c, websocketpp::connection_hdl hdl)</div><div class="ttdef"><b>Definition</b> <a href="scratch__client_8cpp_source.html#l00064">scratch_client.cpp:64</a></div></div>
<div class="ttc" id="aclassconnection__metadata_html_a2aec4aeb2bb18764b4be4e1cfb033fb6"><div class="ttname"><a href="classconnection__metadata.html#a2aec4aeb2bb18764b4be4e1cfb033fb6">connection_metadata::operator&lt;&lt;</a></div><div class="ttdeci">friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp;out, connection_metadata const &amp;data)</div><div class="ttdef"><b>Definition</b> <a href="scratch__client_8cpp_source.html#l00104">scratch_client.cpp:104</a></div></div>
<div class="ttc" id="aclassconnection__metadata_html_ab73db2e336676ec4efa4d4dc5051958f"><div class="ttname"><a href="classconnection__metadata.html#ab73db2e336676ec4efa4d4dc5051958f">connection_metadata::connection_metadata</a></div><div class="ttdeci">connection_metadata(int id, websocketpp::connection_hdl hdl, std::string uri)</div><div class="ttdef"><b>Definition</b> <a href="scratch__client_8cpp_source.html#l00049">scratch_client.cpp:49</a></div></div>
<div class="ttc" id="aclasswebsocketpp_1_1client_html_a818c30343180123bf1fee6dc21524bae"><div class="ttname"><a href="classwebsocketpp_1_1client.html#a818c30343180123bf1fee6dc21524bae">websocketpp::client::connect</a></div><div class="ttdeci">connection_ptr connect(connection_ptr con)</div><div class="ttdoc">Begin the connection process for the given connection.</div><div class="ttdef"><b>Definition</b> <a href="client__endpoint_8hpp_source.html#l00139">client_endpoint.hpp:139</a></div></div>
<div class="ttc" id="aclasswebsocketpp_1_1client_html_aa95cec974921e32bc37a61c683ae240d"><div class="ttname"><a href="classwebsocketpp_1_1client.html#aa95cec974921e32bc37a61c683ae240d">websocketpp::client::get_connection</a></div><div class="ttdeci">connection_ptr get_connection(uri_ptr location, lib::error_code &amp;ec)</div><div class="ttdoc">Get a new connection.</div><div class="ttdef"><b>Definition</b> <a href="client__endpoint_8hpp_source.html#l00089">client_endpoint.hpp:89</a></div></div>
<div class="ttc" id="aclasswebsocketpp_1_1client_html_ad9e541a43023d33d5cd5669d62a13edc"><div class="ttname"><a href="classwebsocketpp_1_1client.html#ad9e541a43023d33d5cd5669d62a13edc">websocketpp::client&lt; websocketpp::config::asio_client &gt;::connection_ptr</a></div><div class="ttdeci">connection_type::ptr connection_ptr</div><div class="ttdef"><b>Definition</b> <a href="client__endpoint_8hpp_source.html#l00060">client_endpoint.hpp:60</a></div></div>
<div class="ttc" id="aclasswebsocketpp_1_1endpoint_html_a0fe4457427d4124abe7ca022ba7afbb4"><div class="ttname"><a href="classwebsocketpp_1_1endpoint.html#a0fe4457427d4124abe7ca022ba7afbb4">websocketpp::endpoint::get_con_from_hdl</a></div><div class="ttdeci">connection_ptr get_con_from_hdl(connection_hdl hdl, lib::error_code &amp;ec)</div><div class="ttdoc">Retrieves a connection_ptr from a connection_hdl (exception free)</div><div class="ttdef"><b>Definition</b> <a href="endpoint_8hpp_source.html#l00643">endpoint.hpp:643</a></div></div>
<div class="ttc" id="acode__cache_8cpp_html_aa0efefe21f4700d78692edc823e763be"><div class="ttname"><a href="code__cache_8cpp.html#aa0efefe21f4700d78692edc823e763be">id</a></div><div class="ttdeci">uint64_t id</div><div class="ttdef"><b>Definition</b> <a href="code__cache_8cpp_source.html#l00000">code_cache.cpp:0</a></div></div>
<div class="ttc" id="adatabase__utils_8hpp_html_a9c651062fd345156256e69573165086c"><div class="ttname"><a href="database__utils_8hpp.html#a9c651062fd345156256e69573165086c">operator&lt;&lt;</a></div><div class="ttdeci">DataStream &amp; operator&lt;&lt;(DataStream &amp;ds, const float64_t &amp;v)</div><div class="ttdef"><b>Definition</b> <a href="database__utils_8hpp_source.html#l00230">database_utils.hpp:230</a></div></div>
<div class="ttc" id="anamespacewebsocketpp_html_a6b3d26a10ee7229b84b776786332631d"><div class="ttname"><a href="namespacewebsocketpp.html#a6b3d26a10ee7229b84b776786332631d">websocketpp::connection_hdl</a></div><div class="ttdeci">lib::weak_ptr&lt; void &gt; connection_hdl</div><div class="ttdoc">A handle to uniquely identify a connection.</div><div class="ttdef"><b>Definition</b> <a href="connection__hdl_8hpp_source.html#l00048">connection_hdl.hpp:48</a></div></div>
</div><!-- fragment --><h2>Step 5</h2>
<p><em>Closing connections</em></p>
<p>This step adds a command that allows you to close a WebSocket connection and adjusts the quit command so that it cleanly closes all outstanding connections before quitting.</p>
<h3>Getting connection close information out of WebSocket++</h3>
<blockquote class="doxtable">
<p>&zwj;##### Terminology: WebSocket close codes &amp; reasons The WebSocket close handshake involves an exchange of optional machine readable close codes and human readable reason strings. Each endpoint sends independent close details. The codes are short integers. The reasons are <a class="el" href="struct_u_t_f8.html" title="UTF-8 encoding.">UTF8</a> text strings of at most 125 characters. More details about valid close code ranges and the meaning of each code can be found at <a href="https://tools.ietf.org/html/rfc6455#section-7.4">https://tools.ietf.org/html/rfc6455#section-7.4</a> </p>
</blockquote>
<p>The <code><a class="el" href="namespacewebsocketpp_1_1close_1_1status.html" title="A package of types and methods for manipulating WebSocket close status&#39;.">websocketpp::close::status</a></code> namespace contains named constants for all of the IANA defined close codes. It also includes free functions to determine whether a value is reserved or invalid and to convert a code to a human readable text representation.</p>
<p>During the close handler call WebSocket++ connections offer the following methods for accessing close handshake information:</p>
<ul>
<li><code>connection::get_remote_close_code()</code>: Get the close code as reported by the remote endpoint</li>
<li><code>connection::get_remote_close_reason()</code>: Get the close reason as reported by the remote endpoint</li>
<li><code>connection::get_local_close_code()</code>: Get the close code that this endpoint sent.</li>
<li><code>connection::get_local_close_reason()</code>: Get the close reason that this endpoint sent.</li>
<li><code>connection::get_ec()</code>: Get a more detailed/specific WebSocket++ <code>error_code</code> indicating what library error (if any) ultimately resulted in the connection closure.</li>
</ul>
<p><em>Note:</em> there are some special close codes that will report a code that was not actually sent on the wire. For example 1005/"no close code" indicates that the endpoint omitted a close code entirely and 1006/"abnormal close" indicates that there was a problem that resulted in the connection closing without having performed a close handshake.</p>
<h3>Add close handler</h3>
<p>The <code><a class="el" href="classconnection__metadata.html#ac297cf7710d8d510ef383b7395222ce5">connection_metadata::on_close</a></code> method is added. This method retrieves the close code and reason from the closing handshake and stores it in the local error reason field.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="debug__server_8cpp.html#ab34f5d876cd49b88fcc768494b7e29fb">on_close</a>(<a class="code hl_class" href="classwebsocketpp_1_1client.html">client</a> * c, <a class="code hl_typedef" href="namespacewebsocketpp.html#a6b3d26a10ee7229b84b776786332631d">websocketpp::connection_hdl</a> hdl) {</div>
<div class="line">    m_status = <span class="stringliteral">&quot;Closed&quot;</span>;</div>
<div class="line">    <a class="code hl_typedef" href="classwebsocketpp_1_1client.html#ad9e541a43023d33d5cd5669d62a13edc">client::connection_ptr</a> con = c-&gt;<a class="code hl_function" href="classwebsocketpp_1_1endpoint.html#a0fe4457427d4124abe7ca022ba7afbb4">get_con_from_hdl</a>(hdl);</div>
<div class="line">    std::stringstream <a class="code hl_variable" href="yubihsm__pkcs11_8c.html#a506da415c9307c897ca9be93acfe1d0f">s</a>;</div>
<div class="line">    <a class="code hl_variable" href="yubihsm__pkcs11_8c.html#a506da415c9307c897ca9be93acfe1d0f">s</a> &lt;&lt; <span class="stringliteral">&quot;close code: &quot;</span> &lt;&lt; con-&gt;get_remote_close_code() &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> </div>
<div class="line">      &lt;&lt; <a class="code hl_function" href="namespacewebsocketpp_1_1close_1_1status.html#a4bf4987c79165b134ed1207a567ce209">websocketpp::close::status::get_string</a>(con-&gt;get_remote_close_code()) </div>
<div class="line">      &lt;&lt; <span class="stringliteral">&quot;), close reason: &quot;</span> &lt;&lt; con-&gt;get_remote_close_reason();</div>
<div class="line">    m_error_reason = <a class="code hl_variable" href="yubihsm__pkcs11_8c.html#a506da415c9307c897ca9be93acfe1d0f">s</a>.str();</div>
<div class="line">}</div>
<div class="ttc" id="adebug__server_8cpp_html_ab34f5d876cd49b88fcc768494b7e29fb"><div class="ttname"><a href="debug__server_8cpp.html#ab34f5d876cd49b88fcc768494b7e29fb">on_close</a></div><div class="ttdeci">void on_close(websocketpp::connection_hdl)</div><div class="ttdef"><b>Definition</b> <a href="debug__server_8cpp_source.html#l00119">debug_server.cpp:119</a></div></div>
<div class="ttc" id="anamespacewebsocketpp_1_1close_1_1status_html_a4bf4987c79165b134ed1207a567ce209"><div class="ttname"><a href="namespacewebsocketpp_1_1close_1_1status.html#a4bf4987c79165b134ed1207a567ce209">websocketpp::close::status::get_string</a></div><div class="ttdeci">std::string get_string(value code)</div><div class="ttdoc">Return a human readable interpretation of a WebSocket close code.</div><div class="ttdef"><b>Definition</b> <a href="close_8hpp_source.html#l00227">close.hpp:227</a></div></div>
<div class="ttc" id="ayubihsm__pkcs11_8c_html_a506da415c9307c897ca9be93acfe1d0f"><div class="ttname"><a href="yubihsm__pkcs11_8c.html#a506da415c9307c897ca9be93acfe1d0f">s</a></div><div class="ttdeci">char * s</div><div class="ttdef"><b>Definition</b> <a href="yubihsm__pkcs11_8c_source.html#l00524">yubihsm_pkcs11.c:524</a></div></div>
</div><!-- fragment --><p>Similarly to <code>on_open</code> and <code>on_fail</code>, <code><a class="el" href="classwebsocket__endpoint.html#a5850523b829e145793d42e137d5eb8c0">websocket_endpoint::connect</a></code> registers this close handler when a new connection is made.</p>
<h3>Add close method to <code><a class="el" href="classwebsocket__endpoint.html">websocket_endpoint</a></code></h3>
<p>This method starts by looking up the given connection ID in the connection list. Next a close request is sent to the connection's handle with the specified WebSocket close code. This is done by calling <code>endpoint::close</code>. This is a thread safe method that is used to asynchronously dispatch a close signal to the connection with the given handle. When the operation is complete the connection's close handler will be triggered.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="integration_8cpp.html#af5b66d867a040d002fb57d645cae3fb4">close</a>(<span class="keywordtype">int</span> <span class="keywordtype">id</span>, <a class="code hl_typedef" href="namespacewebsocketpp_1_1close_1_1status.html#a8614a5c4733d708e2d2a32191c5bef84">websocketpp::close::status::value</a> code) {</div>
<div class="line">    websocketpp::lib::error_code ec;</div>
<div class="line">    </div>
<div class="line">    con_list::iterator metadata_it = m_connection_list.find(<span class="keywordtype">id</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (metadata_it == m_connection_list.end()) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;&gt; No connection found with id &quot;</span> &lt;&lt; <span class="keywordtype">id</span> &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    m_endpoint.close(metadata_it-&gt;second-&gt;get_hdl(), code, <span class="stringliteral">&quot;&quot;</span>, ec);</div>
<div class="line">    <span class="keywordflow">if</span> (ec) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;&gt; Error initiating close: &quot;</span> &lt;&lt; ec.message() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aintegration_8cpp_html_af5b66d867a040d002fb57d645cae3fb4"><div class="ttname"><a href="integration_8cpp.html#af5b66d867a040d002fb57d645cae3fb4">close</a></div><div class="ttdeci">void close(T *e, websocketpp::connection_hdl hdl)</div><div class="ttdef"><b>Definition</b> <a href="integration_8cpp_source.html#l00353">integration.cpp:353</a></div></div>
<div class="ttc" id="anamespacewebsocketpp_1_1close_1_1status_html_a8614a5c4733d708e2d2a32191c5bef84"><div class="ttname"><a href="namespacewebsocketpp_1_1close_1_1status.html#a8614a5c4733d708e2d2a32191c5bef84">websocketpp::close::status::value</a></div><div class="ttdeci">uint16_t value</div><div class="ttdoc">The type of a close code value.</div><div class="ttdef"><b>Definition</b> <a href="close_8hpp_source.html#l00049">close.hpp:49</a></div></div>
</div><!-- fragment --><h3>Add close option to the command loop and help message</h3>
<p><a class="el" href="struct_a.html">A</a> close option is added to the command loop. It takes a connection ID and optionally a close code and a close reason. If no code is specified the default of 1000/Normal is used. If no reason is specified, none is sent. The <code>endpoint::close</code> method will do some error checking and abort the close request if you try and send an invalid code or a reason with invalid <a class="el" href="struct_u_t_f8.html" title="UTF-8 encoding.">UTF8</a> formatting. Reason strings longer than 125 characters will be truncated.</p>
<p>An entry is also added to the help system to describe how the new command may be used.</p>
<div class="fragment"><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (input.substr(0,5) == <span class="stringliteral">&quot;close&quot;</span>) {</div>
<div class="line">    std::stringstream ss(input);</div>
<div class="line">    </div>
<div class="line">    std::string cmd;</div>
<div class="line">    <span class="keywordtype">int</span> <a class="code hl_variable" href="code__cache_8cpp.html#aa0efefe21f4700d78692edc823e763be">id</a>;</div>
<div class="line">    <span class="keywordtype">int</span> close_code = websocketpp::close::status::normal;</div>
<div class="line">    std::string reason;</div>
<div class="line">    </div>
<div class="line">    ss &gt;&gt; cmd &gt;&gt; <span class="keywordtype">id</span> &gt;&gt; close_code;</div>
<div class="line">    std::getline(ss,reason);</div>
<div class="line">    </div>
<div class="line">    endpoint.<a class="code hl_function" href="classwebsocket__endpoint.html#ac18bcc30c3894c74c9ad028b47c299f9">close</a>(<span class="keywordtype">id</span>, close_code, reason);</div>
<div class="line">}</div>
<div class="ttc" id="aclasswebsocket__endpoint_html_ac18bcc30c3894c74c9ad028b47c299f9"><div class="ttname"><a href="classwebsocket__endpoint.html#ac18bcc30c3894c74c9ad028b47c299f9">websocket_endpoint::close</a></div><div class="ttdeci">void close(int id, websocketpp::close::status::value code, std::string reason)</div><div class="ttdef"><b>Definition</b> <a href="scratch__client_8cpp_source.html#l00185">scratch_client.cpp:185</a></div></div>
</div><!-- fragment --><h3>Close all outstanding connections in <code><a class="el" href="classwebsocket__endpoint.html">websocket_endpoint</a></code> destructor</h3>
<p>Until now quitting the program left outstanding connections and the WebSocket++ network thread in a lurch. Now that we have a method of closing connections we can clean this up properly.</p>
<p>The destructor for <code><a class="el" href="classwebsocket__endpoint.html">websocket_endpoint</a></code> now stops perpetual mode (so the run thread exits after the last connection is closed) and iterates through the list of open connections and requests a clean close for each. Finally, the run thread is joined which causes the program to wait until those connection closes complete.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classwebsocket__endpoint.html">~websocket_endpoint</a>() {</div>
<div class="line">    m_endpoint.stop_perpetual();</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> (con_list::const_iterator it = m_connection_list.begin(); it != m_connection_list.end(); ++it) {</div>
<div class="line">        <span class="keywordflow">if</span> (it-&gt;second-&gt;get_status() != <span class="stringliteral">&quot;Open&quot;</span>) {</div>
<div class="line">            <span class="comment">// Only close open connections</span></div>
<div class="line">            <span class="keywordflow">continue</span>;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;&gt; Closing connection &quot;</span> &lt;&lt; it-&gt;second-&gt;get_id() &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        websocketpp::lib::error_code ec;</div>
<div class="line">        m_endpoint.close(it-&gt;second-&gt;get_hdl(), websocketpp::close::status::going_away, <span class="stringliteral">&quot;&quot;</span>, ec);</div>
<div class="line">        <span class="keywordflow">if</span> (ec) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;&gt; Error closing connection &quot;</span> &lt;&lt; it-&gt;second-&gt;get_id() &lt;&lt; <span class="stringliteral">&quot;: &quot;</span>  </div>
<div class="line">                      &lt;&lt; ec.message() &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    m_thread-&gt;join();</div>
<div class="line">}</div>
</div><!-- fragment --><h3>Build</h3>
<p>There are no changes to the build instructions from step 4</p>
<h3>Run</h3>
<div class="fragment"><div class="line">Enter Command: connect ws://localhost:9002</div>
<div class="line">&gt; Created connection with id 0</div>
<div class="line">Enter Command: close 0 1001 example message</div>
<div class="line">Enter Command: show 0</div>
<div class="line">&gt; URI: ws://localhost:9002</div>
<div class="line">&gt; Status: Closed</div>
<div class="line">&gt; Remote Server: WebSocket++/0.4.0</div>
<div class="line">&gt; Error/close reason: close code: 1001 (Going away), close reason:  example message</div>
<div class="line">Enter Command: connect ws://localhost:9002</div>
<div class="line">&gt; Created connection with id 1</div>
<div class="line">Enter Command: close 1 1006</div>
<div class="line">&gt; Error initiating close: Invalid close code used</div>
<div class="line">Enter Command: quit</div>
<div class="line">&gt; Closing connection 1</div>
</div><!-- fragment --><h2>Step 6</h2>
<p><em>Sending and receiving messages</em></p>
<p>This step adds a command to send a message on a given connection and updates the show command to print a transcript of all sent and received messages for that connection.</p>
<blockquote class="doxtable">
<p>&zwj;##### Terminology: WebSocket message types (opcodes) WebSocket messages have types indicated by their opcode. The protocol currently specifies two different opcodes for data messages, text and binary. Text messages represent <a class="el" href="struct_u_t_f8.html" title="UTF-8 encoding.">UTF8</a> text and will be validated as such. <a class="el" href="struct_binary.html">Binary</a> messages represent raw binary bytes and are passed through directly with no validation.</p>
<p>WebSocket++ provides the values <code><a class="el" href="namespacewebsocketpp_1_1frame_1_1opcode.html#ae68711643096dfc4af6d66ade3f9fd5ea6b65f28626b19b2eef447744c564e727">websocketpp::frame::opcode::text</a></code> and <code><a class="el" href="namespacewebsocketpp_1_1frame_1_1opcode.html#ae68711643096dfc4af6d66ade3f9fd5eabe7c19fe7e9744d6a0f041e4c99f120f">websocketpp::frame::opcode::binary</a></code> that can be used to direct how outgoing messages should be sent and to check how incoming messages are formatted. </p>
</blockquote>
<h3>Sending Messages</h3>
<p>Messages are sent using <code>endpoint::send</code>. This is a thread safe method that may be called from anywhere to queue a message for sending on the specified connection. There are three send overloads for use with different scenarios.</p>
<p>Each method takes a <code>connection_hdl</code> to indicate which connection to send the message on as well as a <code>frame::opcode::value</code> to indicate which opcode to label the message as. All overloads are also available with an exception free varient that fills in a a status/error code instead of throwing.</p>
<p>The first overload, <code>connection_hdl hdl, std::string const &amp; payload, frame::opcode::value op</code>, takes a <code>std::string</code>. The string contents are copied into an internal buffer and can be safely modified after calling send.</p>
<p>The second overload, <code>connection_hdl hdl, void const * payload, size_t len, frame::opcode::value op</code>, takes a void * buffer and length. The buffer contents are copied and can be safely modified after calling send.</p>
<p>The third overload, <code>connection_hdl hdl, message_ptr msg</code>, takes a WebSocket++ <code>message_ptr</code>. This overload allows a message to be constructed in place before the call to send. It also may allow a single message buffer to be sent multiple times, including to multiple connections, without copying. Whether or not this actually happens depends on other factors such as whether compression is enabled. The contents of the message buffer may not be safely modified after being sent.</p>
<blockquote class="doxtable">
<p>&zwj;###### Terminology: Outgoing WebSocket message queueing &amp; flow control In many configurations, such as when the Asio based transport is in use, WebSocket++ is an asynchronous system. As such the <code>endpoint::send</code> method may return before any bytes are actually written to the outgoing socket. In cases where send is called multiple times in quick succession messages may be coalesced and sent in the same operation or even the same TCP packet. When this happens the message boundaries are preserved (each call to send will produce a separate message).</p>
<p>In the case of applications that call send from inside a handler this means that no messages will be written to the socket until that handler returns. If you are planning to send many messages in this manor or need a message to be written on the wire before continuing you should look into using multiple threads or the built in timer/interrupt handler functionality.</p>
<p>If the outgoing socket link is slow messages may build up in this queue. You can use <code>connection::get_buffered_amount</code> to query the current size of the written message queue to decide if you want to change your sending behavior. </p>
</blockquote>
<h3>Add send method to <code><a class="el" href="classwebsocket__endpoint.html">websocket_endpoint</a></code></h3>
<p>Like the close method, send will start by looking up the given connection ID in the connection list. Next a send request is sent to the connection's handle with the specified WebSocket message and the text opcode. Finally, we record the sent message with our connection metadata object so later our show connection command can print a list of messages sent.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> send(<span class="keywordtype">int</span> <span class="keywordtype">id</span>, std::string message) {</div>
<div class="line">    websocketpp::lib::error_code ec;</div>
<div class="line">    </div>
<div class="line">    con_list::iterator metadata_it = m_connection_list.find(<span class="keywordtype">id</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (metadata_it == m_connection_list.end()) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;&gt; No connection found with id &quot;</span> &lt;&lt; <span class="keywordtype">id</span> &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    m_endpoint.send(metadata_it-&gt;second-&gt;get_hdl(), message, <a class="code hl_enumvalue" href="namespacewebsocketpp_1_1frame_1_1opcode.html#ae68711643096dfc4af6d66ade3f9fd5ea6b65f28626b19b2eef447744c564e727">websocketpp::frame::opcode::text</a>, ec);</div>
<div class="line">    <span class="keywordflow">if</span> (ec) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;&gt; Error sending message: &quot;</span> &lt;&lt; ec.message() &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    metadata_it-&gt;second-&gt;record_sent_message(message);</div>
<div class="line">}</div>
<div class="ttc" id="anamespacewebsocketpp_1_1frame_1_1opcode_html_ae68711643096dfc4af6d66ade3f9fd5ea6b65f28626b19b2eef447744c564e727"><div class="ttname"><a href="namespacewebsocketpp_1_1frame_1_1opcode.html#ae68711643096dfc4af6d66ade3f9fd5ea6b65f28626b19b2eef447744c564e727">websocketpp::frame::opcode::text</a></div><div class="ttdeci">@ text</div><div class="ttdef"><b>Definition</b> <a href="frame_8hpp_source.html#l00079">frame.hpp:79</a></div></div>
</div><!-- fragment --><h3>Add send option to the command loop and help message</h3>
<p><a class="el" href="struct_a.html">A</a> send option is added to the command loop. It takes a connection ID and a text message to send. An entry is also added to the help system to describe how the new command may be used.</p>
<div class="fragment"><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (input.substr(0,4) == <span class="stringliteral">&quot;send&quot;</span>) {</div>
<div class="line">    std::stringstream ss(input);</div>
<div class="line">        </div>
<div class="line">        std::string cmd;</div>
<div class="line">        <span class="keywordtype">int</span> <a class="code hl_variable" href="code__cache_8cpp.html#aa0efefe21f4700d78692edc823e763be">id</a>;</div>
<div class="line">        std::string message = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line">        </div>
<div class="line">        ss &gt;&gt; cmd &gt;&gt; <a class="code hl_variable" href="code__cache_8cpp.html#aa0efefe21f4700d78692edc823e763be">id</a>;</div>
<div class="line">        std::getline(ss,message);</div>
<div class="line">        </div>
<div class="line">        endpoint.<a class="code hl_function" href="classwebsocket__endpoint.html#aaae3d15cae0c3d7fd134ca28676e53cc">send</a>(<span class="keywordtype">id</span>, message);</div>
<div class="line">}</div>
<div class="ttc" id="aclasswebsocket__endpoint_html_aaae3d15cae0c3d7fd134ca28676e53cc"><div class="ttname"><a href="classwebsocket__endpoint.html#aaae3d15cae0c3d7fd134ca28676e53cc">websocket_endpoint::send</a></div><div class="ttdeci">void send(int id, std::string message)</div><div class="ttdef"><b>Definition</b> <a href="utility__client_8cpp_source.html#l00225">utility_client.cpp:225</a></div></div>
</div><!-- fragment --><h3>Add glue to <code><a class="el" href="classconnection__metadata.html">connection_metadata</a></code> for storing sent messages</h3>
<p>In order to store messages sent on this connection some code is added to <code><a class="el" href="classconnection__metadata.html">connection_metadata</a></code>. This includes a new data member <code>std::vector&lt;std::string&gt; m_messages</code> to keep track of all messages sent and received as well as a method for adding a sent message in that list:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> record_sent_message(std::string message) {</div>
<div class="line">    m_messages.push_back(<span class="stringliteral">&quot;&gt;&gt; &quot;</span> + message);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Finally the connection metadata output operator is updated to also print a list of processed messages:</p>
<div class="fragment"><div class="line">out &lt;&lt; <span class="stringliteral">&quot;&gt; Messages Processed: (&quot;</span> &lt;&lt; data.m_messages.size() &lt;&lt; <span class="stringliteral">&quot;) \n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">std::vector&lt;std::string&gt;::const_iterator it;</div>
<div class="line"><span class="keywordflow">for</span> (it = data.m_messages.begin(); it != data.m_messages.end(); ++it) {</div>
<div class="line">    out &lt;&lt; *it &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><h3>Receiving Messages</h3>
<p>Messages are received by registering a message handler. This handler will be called once per message received and its signature is <code>void on_message(websocketpp::connection_hdl hdl, endpoint::message_ptr msg)</code>. The <code>connection_hdl</code>, like the similar parameter from the other handlers is a handle for the connection that the message was received on. The <code>message_ptr</code> is a pointer to an object that can be queried for the message payload, opcode, and other metadata. Note that the message_ptr type, as well as its underlying message type, is dependent on how your endpoint is configured and may be different for different configs.</p>
<h3>Add a message handler to method to <code><a class="el" href="classconnection__metadata.html">connection_metadata</a></code></h3>
<p>The message receiving behave that we are implementing will be to collect all messages sent and received and to print them in order when the show connection command is run. The sent messages are already being added to that list. Now we add a message handler that pushes received messages to the list as well. Text messages are pushed as-is. <a class="el" href="struct_binary.html">Binary</a> messages are first converted to printable hexadecimal format.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="debug__server_8cpp.html#a9a10d63d7c00e9917ce373bf47bda4b6">on_message</a>(<a class="code hl_typedef" href="namespacewebsocketpp.html#a6b3d26a10ee7229b84b776786332631d">websocketpp::connection_hdl</a> hdl, <a class="code hl_typedef" href="classwebsocketpp_1_1endpoint.html#a8097edab4feb0c36a69601c3786f0062">client::message_ptr</a> msg) {</div>
<div class="line">    <span class="keywordflow">if</span> (msg-&gt;get_opcode() == <a class="code hl_enumvalue" href="namespacewebsocketpp_1_1frame_1_1opcode.html#ae68711643096dfc4af6d66ade3f9fd5ea6b65f28626b19b2eef447744c564e727">websocketpp::frame::opcode::text</a>) {</div>
<div class="line">        m_messages.push_back(msg-&gt;get_payload());</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        m_messages.push_back(<a class="code hl_function" href="namespacewebsocketpp_1_1utility.html#a26e5a26395d95d2f6bf3a9edb8d06dd2">websocketpp::utility::to_hex</a>(msg-&gt;get_payload()));</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclasswebsocketpp_1_1endpoint_html_a8097edab4feb0c36a69601c3786f0062"><div class="ttname"><a href="classwebsocketpp_1_1endpoint.html#a8097edab4feb0c36a69601c3786f0062">websocketpp::endpoint&lt; connection&lt; config &gt;, config &gt;::message_ptr</a></div><div class="ttdeci">connection_type::message_ptr message_ptr</div><div class="ttdef"><b>Definition</b> <a href="endpoint_8hpp_source.html#l00070">endpoint.hpp:70</a></div></div>
<div class="ttc" id="adebug__server_8cpp_html_a9a10d63d7c00e9917ce373bf47bda4b6"><div class="ttname"><a href="debug__server_8cpp.html#a9a10d63d7c00e9917ce373bf47bda4b6">on_message</a></div><div class="ttdeci">void on_message(server *s, websocketpp::connection_hdl hdl, message_ptr msg)</div><div class="ttdef"><b>Definition</b> <a href="debug__server_8cpp_source.html#l00124">debug_server.cpp:124</a></div></div>
<div class="ttc" id="anamespacewebsocketpp_1_1utility_html_a26e5a26395d95d2f6bf3a9edb8d06dd2"><div class="ttname"><a href="namespacewebsocketpp_1_1utility.html#a26e5a26395d95d2f6bf3a9edb8d06dd2">websocketpp::utility::to_hex</a></div><div class="ttdeci">std::string to_hex(std::string const &amp;input)</div><div class="ttdoc">Convert std::string to ascii printed string of hex digits.</div><div class="ttdef"><b>Definition</b> <a href="utilities__impl_8hpp_source.html#l00043">utilities_impl.hpp:43</a></div></div>
</div><!-- fragment --><p>In order to have this handler called when new messages are received we also register it with our connection. Note that unlike most other handlers, the message handler has two parameters and thus needs two placeholders.</p>
<div class="fragment"><div class="line">con-&gt;set_message_handler(websocketpp::lib::bind(</div>
<div class="line">    &amp;<a class="code hl_function" href="classconnection__metadata.html#a78708ddd026fc4fbff883477c0ed01bf">connection_metadata::on_message</a>,</div>
<div class="line">    metadata_ptr,</div>
<div class="line">    websocketpp::lib::placeholders::_1,</div>
<div class="line">    websocketpp::lib::placeholders::_2</div>
<div class="line">));</div>
<div class="ttc" id="aclassconnection__metadata_html_a78708ddd026fc4fbff883477c0ed01bf"><div class="ttname"><a href="classconnection__metadata.html#a78708ddd026fc4fbff883477c0ed01bf">connection_metadata::on_message</a></div><div class="ttdeci">void on_message(websocketpp::connection_hdl, client::message_ptr msg)</div><div class="ttdef"><b>Definition</b> <a href="utility__client_8cpp_source.html#l00082">utility_client.cpp:82</a></div></div>
</div><!-- fragment --><h3>Build</h3>
<p>There are no changes to the build instructions from step 5</p>
<h3>Run</h3>
<p>In this example run we are connecting to the WebSocket++ example echo_server. This server will repeat any message we send back to it. You can also try testing this with the echo server at <code>ws://echo.websocket.org</code> with similar results.</p>
<div class="fragment"><div class="line">Enter Command: connect ws://localhost:9002</div>
<div class="line">&gt; Created connection with id 0</div>
<div class="line">Enter Command: send 0 example message</div>
<div class="line">Enter Command: show 0</div>
<div class="line">&gt; URI: ws://localhost:9002</div>
<div class="line">&gt; Status: Open</div>
<div class="line">&gt; Remote Server: WebSocket++/0.4.0</div>
<div class="line">&gt; Error/close reason: N/A</div>
<div class="line">&gt; Messages Processed: (2)</div>
<div class="line">&gt;&gt;  example message</div>
<div class="line">&lt;&lt;  example message</div>
</div><!-- fragment --><h2>Step 7</h2>
<p><em>Using TLS / Secure WebSockets</em></p>
<ul>
<li>Change the includes</li>
<li>link to the new library dependencies</li>
<li>Switch the config</li>
<li>add the <code>tls_init_handler</code></li>
<li>configure the SSL context for desired security level</li>
<li>mixing secure and non-secure connections in one application.</li>
</ul>
<h1>Chapter 2: Intermediate Features </h1>
<h2>Step 8</h2>
<p><em>Intermediate level features</em></p>
<ul>
<li>Subprotocol negotiation</li>
<li>Setting and reading custom headers</li>
<li>Ping and Pong</li>
<li>Proxies?</li>
<li>Setting user agent</li>
<li>Setting Origin</li>
<li>Timers and security</li>
<li>Close behavior</li>
<li>Send one message to all connections</li>
</ul>
<h2>Misc stuff not sure if it should be included here or elsewhere?</h2>
<p>core websocket++ control flow. <a class="el" href="struct_a.html">A</a> handshake, followed by a split into 2 independent control strands</p><ul>
<li>Handshake &ndash; use information specified before the call to endpoint::connect to construct a WebSocket handshake request. &ndash; Pass the WebSocket handshake request to the transport policy. The transport policy determines how to get these bytes to the endpoint playing the server role. Depending on which transport policy your endpoint uses this method will be different. &ndash; Receive a handshake response from the underlying transport. This is parsed and checked for conformance to RFC6455. If the validation fails, the fail handler is called. Otherwise the open handler is called.</li>
<li>At this point control splits into two separate strands. One that reads new bytes from the transport policy on the incoming channle, the other that accepts new messages from the local application for framing and writing to the outgoing transport channel.</li>
<li>Read strand &ndash; Read and process new bytes from transport &ndash; If the bytes contain at least one complete message dispatch each message by calling the appropriate handler. This is either the message handler for data messages, or ping/pong/close handlers for each respective control message. If no handler is registered for a particular message it is ignored. &ndash; Ask the transport layer for more bytes</li>
<li>Write strand &ndash; Wait for messages from the application &ndash; Perform error checking on message input, &ndash; Frame message per RFC6455 &ndash; <a class="el" href="class_queue.html">Queue</a> message for sending &ndash; Pass all outstanding messages to the transport policy for output &ndash; When there are no messages left to send, return to waiting</li>
</ul>
<p>Important observations Handlers run in line with library processing which has several implications applications should be aware of: </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
