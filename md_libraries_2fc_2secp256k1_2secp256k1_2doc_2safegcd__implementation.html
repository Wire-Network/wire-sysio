<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Wire Sysio: The safegcd implementation in libsecp256k1 explained</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Wire Sysio<span id="projectnumber">&#160;Wire Sysion 1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_libraries_2fc_2secp256k1_2secp256k1_2doc_2safegcd__implementation.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">The safegcd implementation in libsecp256k1 explained</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This document explains the modular inverse implementation in the <code>src/modinv*.h</code> files. It is based on the paper <a href="https://gcd.cr.yp.to/papers.html#safegcd">"Fast constant-time gcd computation and modular inversion"</a> by Daniel J. Bernstein and Bo-Yin Yang. The references below are for the Date: 2019.04.13 version.</p>
<p>The actual implementation is in C of course, but for demonstration purposes Python3 is used here. Most implementation aspects and optimizations are explained, except those that depend on the specific number representation used in the C code.</p>
<h1>1. Computing the Greatest Common Divisor (GCD) using divsteps</h1>
<p>The algorithm from the paper (section 11), at a very high level, is this:</p>
<div class="fragment"><div class="line"><span class="keyword">def </span>gcd(f, g):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Compute the GCD of an odd integer f and another integer g.&quot;&quot;&quot;</span></div>
<div class="line">    <span class="keyword">assert</span> f &amp; 1  <span class="comment"># require f to be odd</span></div>
<div class="line">    delta = 1     <span class="comment"># additional state variable</span></div>
<div class="line">    <span class="keywordflow">while</span> g != 0:</div>
<div class="line">        <span class="keyword">assert</span> f &amp; 1  <span class="comment"># f will be odd in every iteration</span></div>
<div class="line">        <span class="keywordflow">if</span> delta &gt; 0 <span class="keywordflow">and</span> g &amp; 1:</div>
<div class="line">            delta, f, g = 1 - delta, g, (g - f) // 2</div>
<div class="line">        <span class="keywordflow">elif</span> g &amp; 1:</div>
<div class="line">            delta, f, g = 1 + delta, f, (g + f) // 2</div>
<div class="line">        <span class="keywordflow">else</span>:</div>
<div class="line">            delta, f, g = 1 + delta, f, (g    ) // 2</div>
<div class="line">    <span class="keywordflow">return</span> abs(f)</div>
</div><!-- fragment --><p>It computes the greatest common divisor of an odd integer <em>f</em> and any integer <em>g</em>. Its inner loop keeps rewriting the variables <em>f</em> and <em>g</em> alongside a state variable <em>&delta;</em> that starts at <em>1</em>, until <em>g=0</em> is reached. At that point, *|f|* gives the GCD. Each of the transitions in the loop is called a "division step" (referred to as divstep in what follows).</p>
<p>For example, <em>gcd(21, 14)</em> would be computed as:</p><ul>
<li>Start with <em>&delta;=1 f=21 g=14</em></li>
<li>Take the third branch: <em>&delta;=2 f=21 g=7</em></li>
<li>Take the first branch: <em>&delta;=-1 f=7 g=-7</em></li>
<li>Take the second branch: <em>&delta;=0 f=7 g=0</em></li>
<li>The answer *|f| = 7*.</li>
</ul>
<p>Why it works:</p><ul>
<li>Divsteps can be decomposed into two steps (see paragraph 8.2 in the paper):<ul>
<li>(a) If <em>g</em> is odd, replace <em>(f,g)</em> with <em>(g,g-f)</em> or (f,g+f), resulting in an even <em>g</em>.</li>
<li>(b) Replace <em>(f,g)</em> with <em>(f,g/2)</em> (where <em>g</em> is guaranteed to be even).</li>
</ul>
</li>
<li>Neither of those two operations change the GCD:<ul>
<li>For (a), assume <em>gcd(f,g)=c</em>, then it must be the case that <em>f=a&thinsp;c</em> and <em>g=b&thinsp;c</em> for some integers <em>a</em> and <em>b</em>. As <em>(g,g-f)=(b&thinsp;c,(b-a)c)</em> and <em>(f,f+g)=(a&thinsp;c,(a+b)c)</em>, the result clearly still has common factor <em>c</em>. Reasoning in the other direction shows that no common factor can be added by doing so either.</li>
<li>For (b), we know that <em>f</em> is odd, so <em>gcd(f,g)</em> clearly has no factor <em>2</em>, and we can remove it from <em>g</em>.</li>
</ul>
</li>
<li>The algorithm will eventually converge to <em>g=0</em>. This is proven in the paper (see theorem G.3).</li>
<li>It follows that eventually we find a final value <em>f'</em> for which <em>gcd(f,g) = gcd(f',0)</em>. As the gcd of <em>f'</em> and <em>0</em> is *|f'|* by definition, that is our answer.</li>
</ul>
<p>Compared to more <a href="https://en.wikipedia.org/wiki/Euclidean_algorithm">traditional GCD algorithms</a>, this one has the property of only ever looking at the low-order bits of the variables to decide the next steps, and being easy to make constant-time (in more low-level languages than Python). The <em>&delta;</em> parameter is necessary to guide the algorithm towards shrinking the numbers' magnitudes without explicitly needing to look at high order bits.</p>
<p>Properties that will become important later:</p><ul>
<li>Performing more divsteps than needed is not a problem, as <em>f</em> does not change anymore after <em>g=0</em>.</li>
<li>Only even numbers are divided by <em>2</em>. This means that when reasoning about it algebraically we do not need to worry about rounding.</li>
<li>At every point during the algorithm's execution the next <em>N</em> steps only depend on the bottom <em>N</em> bits of <em>f</em> and <em>g</em>, and on <em>&delta;</em>.</li>
</ul>
<h1>2. From GCDs to modular inverses</h1>
<p>We want an algorithm to compute the inverse <em>a</em> of <em>x</em> modulo <em>M</em>, i.e. the number a such that <em>a&thinsp;x=1 mod M</em>. This inverse only exists if the GCD of <em>x</em> and <em>M</em> is <em>1</em>, but that is always the case if <em>M</em> is prime and <em>0 &lt; x &lt; M</em>. In what follows, assume that the modular inverse exists. It turns out this inverse can be computed as a side effect of computing the GCD by keeping track of how the internal variables can be written as linear combinations of the inputs at every step (see the <a href="https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm">extended Euclidean algorithm</a>). Since the GCD is <em>1</em>, such an algorithm will compute numbers <em>a</em> and <em>b</em> such that a&thinsp;x + b&thinsp;M = 1*. Taking that expression <em>mod M</em> gives <em>a&thinsp;x mod M = 1</em>, and we see that <em>a</em> is the modular inverse of <em>x mod M</em>.</p>
<p><a class="el" href="struct_a.html">A</a> similar approach can be used to calculate modular inverses using the divsteps-based GCD algorithm shown above, if the modulus <em>M</em> is odd. To do so, compute <em>gcd(f=M,g=x)</em>, while keeping track of extra variables <em>d</em> and <em>e</em>, for which at every step <em>d = f/x (mod M)</em> and <em>e = g/x (mod M)</em>. <em>f/x</em> here means the number which multiplied with <em>x</em> gives <em>f mod M</em>. As <em>f</em> and <em>g</em> are initialized to <em>M</em> and <em>x</em> respectively, <em>d</em> and <em>e</em> just start off being <em>0</em> (<em>M/x mod M = 0/x mod M = 0</em>) and <em>1</em> (<em>x/x mod M = 1</em>).</p>
<div class="fragment"><div class="line"><span class="keyword">def </span>div2(M, x):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Helper routine to compute x/2 mod M (where M is odd).&quot;&quot;&quot;</span></div>
<div class="line">    <span class="keyword">assert</span> M &amp; 1</div>
<div class="line">    <span class="keywordflow">if</span> x &amp; 1: <span class="comment"># If x is odd, make it even by adding M.</span></div>
<div class="line">        x += M</div>
<div class="line">    <span class="comment"># x must be even now, so a clean division by 2 is possible.</span></div>
<div class="line">    <span class="keywordflow">return</span> x // 2</div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>modinv(M, x):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Compute the inverse of x mod M (given that it exists, and M is odd).&quot;&quot;&quot;</span></div>
<div class="line">    <span class="keyword">assert</span> M &amp; 1</div>
<div class="line">    delta, f, g, d, e = 1, M, x, 0, 1</div>
<div class="line">    <span class="keywordflow">while</span> g != 0:</div>
<div class="line">        <span class="comment"># Note that while division by two for f and g is only ever done on even inputs, this is</span></div>
<div class="line">        <span class="comment"># not true for d and e, so we need the div2 helper function.</span></div>
<div class="line">        <span class="keywordflow">if</span> delta &gt; 0 <span class="keywordflow">and</span> g &amp; 1:</div>
<div class="line">            delta, f, g, d, e = 1 - delta, g, (g - f) // 2, e, div2(M, e - d)</div>
<div class="line">        <span class="keywordflow">elif</span> g &amp; 1:</div>
<div class="line">            delta, f, g, d, e = 1 + delta, f, (g + f) // 2, d, div2(M, e + d)</div>
<div class="line">        <span class="keywordflow">else</span>:</div>
<div class="line">            delta, f, g, d, e = 1 + delta, f, (g    ) // 2, d, div2(M, e    )</div>
<div class="line">        <span class="comment"># Verify that the invariants d=f/x mod M, e=g/x mod M are maintained.</span></div>
<div class="line">        <span class="keyword">assert</span> f % M == (d * x) % M</div>
<div class="line">        <span class="keyword">assert</span> g % M == (e * x) % M</div>
<div class="line">    <span class="keyword">assert</span> f == 1 <span class="keywordflow">or</span> f == -1  <span class="comment"># |f| is the GCD, it must be 1</span></div>
<div class="line">    <span class="comment"># Because of invariant d = f/x (mod M), 1/x = d/f (mod M). As |f|=1, d/f = d*f.</span></div>
<div class="line">    <span class="keywordflow">return</span> (d * f) % M</div>
</div><!-- fragment --><p>Also note that this approach to track <em>d</em> and <em>e</em> throughout the computation to determine the inverse is different from the paper. There (see paragraph 12.1 in the paper) a transition matrix for the entire computation is determined (see section 3 below) and the inverse is computed from that. The approach here avoids the need for 2x2 matrix multiplications of various sizes, and appears to be faster at the level of optimization we're able to do in C.</p>
<h1>3. Batching multiple divsteps</h1>
<p>Every divstep can be expressed as a matrix multiplication, applying a transition matrix <em>(1/2 t)</em> to both vectors <em>[f, g]</em> and <em>[d, e]</em> (see paragraph 8.1 in the paper):</p>
<div class="fragment"><div class="line">t = [ u,  v ]</div>
<div class="line">    [ q,  r ]</div>
<div class="line"> </div>
<div class="line">[ out_f ] = (1/2 * t) * [ in_f ]</div>
<div class="line">[ out_g ] =             [ in_g ]</div>
<div class="line"> </div>
<div class="line">[ out_d ] = (1/2 * t) * [ in_d ]  (mod M)</div>
<div class="line">[ out_e ]               [ in_e ]</div>
</div><!-- fragment --><p>where <em>(u, v, q, r)</em> is <em>(0, 2, -1, 1)</em>, <em>(2, 0, 1, 1)</em>, or <em>(2, 0, 0, 1)</em>, depending on which branch is taken. As above, the resulting <em>f</em> and <em>g</em> are always integers.</p>
<p>Performing multiple divsteps corresponds to a multiplication with the product of all the individual divsteps' transition matrices. As each transition matrix consists of integers divided by <em>2</em>, the product of these matrices will consist of integers divided by *2<sup>N</sup>* (see also theorem 9.2 in the paper). These divisions are expensive when updating <em>d</em> and <em>e</em>, so we delay them: we compute the integer coefficients of the combined transition matrix scaled by *2<sup>N</sup>*, and do one division by *2<sup>N</sup>* as a final step:</p>
<div class="fragment"><div class="line"><span class="keyword">def </span>divsteps_n_matrix(delta, f, g):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Compute delta and transition matrix t after N divsteps (multiplied by 2^N).&quot;&quot;&quot;</span></div>
<div class="line">    u, v, q, r = 1, 0, 0, 1 <span class="comment"># start with identity matrix</span></div>
<div class="line">    <span class="keywordflow">for</span> _ <span class="keywordflow">in</span> range(N):</div>
<div class="line">        <span class="keywordflow">if</span> delta &gt; 0 <span class="keywordflow">and</span> g &amp; 1:</div>
<div class="line">            delta, f, g, u, v, q, r = 1 - delta, g, (g - f) // 2, 2*q, 2*r, q-u, r-v</div>
<div class="line">        <span class="keywordflow">elif</span> g &amp; 1:</div>
<div class="line">            delta, f, g, u, v, q, r = 1 + delta, f, (g + f) // 2, 2*u, 2*v, q+u, r+v</div>
<div class="line">        <span class="keywordflow">else</span>:</div>
<div class="line">            delta, f, g, u, v, q, r = 1 + delta, f, (g    ) // 2, 2*u, 2*v, q  , r</div>
<div class="line">    <span class="keywordflow">return</span> delta, (u, v, q, r)</div>
</div><!-- fragment --><p>As the branches in the divsteps are completely determined by the bottom <em>N</em> bits of <em>f</em> and <em>g</em>, this function to compute the transition matrix only needs to see those bottom bits. Furthermore all intermediate results and outputs fit in <em>(N+1)</em>-bit numbers (unsigned for <em>f</em> and <em>g</em>; signed for <em>u</em>, <em>v</em>, <em>q</em>, and <em>r</em>) (see also paragraph 8.3 in the paper). This means that an implementation using 64-bit integers could set <em>N=62</em> and compute the full transition matrix for 62 steps at once without any big integer arithmetic at all. This is the reason why this algorithm is efficient: it only needs to update the full-size <em>f</em>, <em>g</em>, <em>d</em>, and <em>e</em> numbers once every <em>N</em> steps.</p>
<p>We still need functions to compute:</p>
<div class="fragment"><div class="line">[ out_f ] = (1/2^N * [ u,  v ]) * [ in_f ]</div>
<div class="line">[ out_g ]   (        [ q,  r ])   [ in_g ]</div>
<div class="line"> </div>
<div class="line">[ out_d ] = (1/2^N * [ u,  v ]) * [ in_d ]  (mod M)</div>
<div class="line">[ out_e ]   (        [ q,  r ])   [ in_e ]</div>
</div><!-- fragment --><p>Because the divsteps transformation only ever divides even numbers by two, the result of <em>t&thinsp;[f,g]</em> is always even. When <em>t</em> is a composition of <em>N</em> divsteps, it follows that the resulting <em>f</em> and <em>g</em> will be multiple of *2<sup>N</sup>*, and division by *2<sup>N</sup>* is simply shifting them down:</p>
<div class="fragment"><div class="line"><span class="keyword">def </span>update_fg(f, g, t):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Multiply matrix t/2^N with [f, g].&quot;&quot;&quot;</span></div>
<div class="line">    u, v, q, r = t</div>
<div class="line">    cf, cg = u*f + v*g, q*f + r*g</div>
<div class="line">    <span class="comment"># (t / 2^N) should cleanly apply to [f,g] so the result of t*[f,g] should have N zero</span></div>
<div class="line">    <span class="comment"># bottom bits.</span></div>
<div class="line">    <span class="keyword">assert</span> cf % 2**N == 0</div>
<div class="line">    <span class="keyword">assert</span> cg % 2**N == 0</div>
<div class="line">    <span class="keywordflow">return</span> cf &gt;&gt; N, cg &gt;&gt; N</div>
</div><!-- fragment --><p>The same is not true for <em>d</em> and <em>e</em>, and we need an equivalent of the <code>div2</code> function for division by *2<sup>N</sup> mod M*. This is easy if we have precomputed *1/M mod 2<sup>N</sup>* (which always exists for odd <em>M</em>):</p>
<div class="fragment"><div class="line"><span class="keyword">def </span>div2n(M, Mi, x):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Compute x/2^N mod M, given Mi = 1/M mod 2^N.&quot;&quot;&quot;</span></div>
<div class="line">    <span class="keyword">assert</span> (M * Mi) % 2**N == 1</div>
<div class="line">    <span class="comment"># Find a factor m such that m*M has the same bottom N bits as x. We want:</span></div>
<div class="line">    <span class="comment">#     (m * M) mod 2^N = x mod 2^N</span></div>
<div class="line">    <span class="comment"># &lt;=&gt; m mod 2^N = (x / M) mod 2^N</span></div>
<div class="line">    <span class="comment"># &lt;=&gt; m mod 2^N = (x * Mi) mod 2^N</span></div>
<div class="line">    m = (Mi * x) % 2**N</div>
<div class="line">    <span class="comment"># Subtract that multiple from x, cancelling its bottom N bits.</span></div>
<div class="line">    x -= m * M</div>
<div class="line">    <span class="comment"># Now a clean division by 2^N is possible.</span></div>
<div class="line">    <span class="keyword">assert</span> x % 2**N == 0</div>
<div class="line">    <span class="keywordflow">return</span> (x &gt;&gt; N) % M</div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>update_de(d, e, t, M, Mi):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Multiply matrix t/2^N with [d, e], modulo M.&quot;&quot;&quot;</span></div>
<div class="line">    u, v, q, r = t</div>
<div class="line">    cd, ce = u*d + v*e, q*d + r*e</div>
<div class="line">    <span class="keywordflow">return</span> div2n(M, Mi, cd), div2n(M, Mi, ce)</div>
</div><!-- fragment --><p>With all of those, we can write a version of <code>modinv</code> that performs <em>N</em> divsteps at once:</p>
<div class="fragment"><div class="line"> 3</div>
<div class="line"><span class="keyword">def </span>modinv(M, Mi, x):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Compute the modular inverse of x mod M, given Mi=1/M mod 2^N.&quot;&quot;&quot;</span></div>
<div class="line">    <span class="keyword">assert</span> M &amp; 1</div>
<div class="line">    delta, f, g, d, e = 1, M, x, 0, 1</div>
<div class="line">    <span class="keywordflow">while</span> g != 0:</div>
<div class="line">        <span class="comment"># Compute the delta and transition matrix t for the next N divsteps (this only needs</span></div>
<div class="line">        <span class="comment"># (N+1)-bit signed integer arithmetic).</span></div>
<div class="line">        delta, t = divsteps_n_matrix(delta, f % 2**N, g % 2**N)</div>
<div class="line">        <span class="comment"># Apply the transition matrix t to [f, g]:</span></div>
<div class="line">        f, g = update_fg(f, g, t)</div>
<div class="line">        <span class="comment"># Apply the transition matrix t to [d, e]:</span></div>
<div class="line">        d, e = update_de(d, e, t, M, Mi)</div>
<div class="line">    <span class="keywordflow">return</span> (d * f) % M</div>
</div><!-- fragment --><p>This means that in practice we'll always perform a multiple of <em>N</em> divsteps. This is not a problem because once <em>g=0</em>, further divsteps do not affect <em>f</em>, <em>g</em>, <em>d</em>, or <em>e</em> anymore (only <em>&delta;</em> keeps increasing). For variable time code such excess iterations will be mostly optimized away in later sections.</p>
<h1>4. Avoiding modulus operations</h1>
<p>So far, there are two places where we compute a remainder of big numbers modulo <em>M</em>: at the end of <code>div2n</code> in every <code>update_de</code>, and at the very end of <code>modinv</code> after potentially negating <em>d</em> due to the sign of <em>f</em>. These are relatively expensive operations when done generically.</p>
<p>To deal with the modulus operation in <code>div2n</code>, we simply stop requiring <em>d</em> and <em>e</em> to be in range <em>[0,M)</em> all the time. Let's start by inlining <code>div2n</code> into <code>update_de</code>, and dropping the modulus operation at the end:</p>
<div class="fragment"><div class="line"><span class="keyword">def </span>update_de(d, e, t, M, Mi):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Multiply matrix t/2^N with [d, e] mod M, given Mi=1/M mod 2^N.&quot;&quot;&quot;</span></div>
<div class="line">    u, v, q, r = t</div>
<div class="line">    cd, ce = u*d + v*e, q*d + r*e</div>
<div class="line">    <span class="comment"># Cancel out bottom N bits of cd and ce.</span></div>
<div class="line">    md = -((Mi * cd) % 2**N)</div>
<div class="line">    me = -((Mi * ce) % 2**N)</div>
<div class="line">    cd += md * M</div>
<div class="line">    ce += me * M</div>
<div class="line">    <span class="comment"># And cleanly divide by 2**N.</span></div>
<div class="line">    <span class="keywordflow">return</span> cd &gt;&gt; N, ce &gt;&gt; N</div>
</div><!-- fragment --><p>Let's look at bounds on the ranges of these numbers. It can be shown that *|u|+|v|* and *|q|+|r|* never exceed *2<sup>N</sup>* (see paragraph 8.3 in the paper), and thus a multiplication with <em>t</em> will have outputs whose absolute values are at most *2<sup>N</sup>* times the maximum absolute input value. In case the inputs <em>d</em> and <em>e</em> are in <em>(-M,M)</em>, which is certainly true for the initial values <em>d=0</em> and <em>e=1</em> assuming <em>M &gt; 1</em>, the multiplication results in numbers in range *(-2<sup>N</sup>M,2<sup>N</sup>M)*. Subtracting less than *2<sup>N</sup>* times <em>M</em> to cancel out <em>N</em> bits brings that up to *(-2<sup>N+1</sup>M,2<sup>N</sup>M)*, and dividing by *2<sup>N</sup>* at the end takes it to <em>(-2M,M)</em>. Another application of <code>update_de</code> would take that to <em>(-3M,2M)</em>, and so forth. This progressive expansion of the variables' ranges can be counteracted by incrementing <em>d</em> and <em>e</em> by <em>M</em> whenever they're negative:</p>
<div class="fragment"><div class="line">...</div>
<div class="line"><span class="keywordflow">if</span> d &lt; 0:</div>
<div class="line">    d += M</div>
<div class="line"><span class="keywordflow">if</span> e &lt; 0:</div>
<div class="line">    e += M</div>
<div class="line">cd, ce = u*d + v*e, q*d + r*e</div>
<div class="line"><span class="comment"># Cancel out bottom N bits of cd and ce.</span></div>
<div class="line">...</div>
</div><!-- fragment --><p>With inputs in <em>(-2M,M)</em>, they will first be shifted into range <em>(-M,M)</em>, which means that the output will again be in <em>(-2M,M)</em>, and this remains the case regardless of how many <code>update_de</code> invocations there are. In what follows, we will try to make this more efficient.</p>
<p>Note that increasing <em>d</em> by <em>M</em> is equal to incrementing <em>cd</em> by <em>u&thinsp;M</em> and <em>ce</em> by <em>q&thinsp;M</em>. Similarly, increasing <em>e</em> by <em>M</em> is equal to incrementing <em>cd</em> by <em>v&thinsp;M</em> and <em>ce</em> by <em>r&thinsp;M</em>. So we could instead write:</p>
<div class="fragment"><div class="line">...</div>
<div class="line">cd, ce = u*d + v*e, q*d + r*e</div>
<div class="line"><span class="comment"># Perform the equivalent of incrementing d, e by M when they&#39;re negative.</span></div>
<div class="line"><span class="keywordflow">if</span> d &lt; 0:</div>
<div class="line">    cd += u*M</div>
<div class="line">    ce += q*M</div>
<div class="line"><span class="keywordflow">if</span> e &lt; 0:</div>
<div class="line">    cd += v*M</div>
<div class="line">    ce += r*M</div>
<div class="line"><span class="comment"># Cancel out bottom N bits of cd and ce.</span></div>
<div class="line">md = -((Mi * cd) % 2**N)</div>
<div class="line">me = -((Mi * ce) % 2**N)</div>
<div class="line">cd += md * M</div>
<div class="line">ce += me * M</div>
<div class="line">...</div>
</div><!-- fragment --><p>Now note that we have two steps of corrections to <em>cd</em> and <em>ce</em> that add multiples of <em>M</em>: this increment, and the decrement that cancels out bottom bits. The second one depends on the first one, but they can still be efficiently combined by only computing the bottom bits of <em>cd</em> and <em>ce</em> at first, and using that to compute the final <em>md</em>, <em>me</em> values:</p>
<div class="fragment"><div class="line"><span class="keyword">def </span>update_de(d, e, t, M, Mi):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Multiply matrix t/2^N with [d, e], modulo M.&quot;&quot;&quot;</span></div>
<div class="line">    u, v, q, r = t</div>
<div class="line">    md, me = 0, 0</div>
<div class="line">    <span class="comment"># Compute what multiples of M to add to cd and ce.</span></div>
<div class="line">    <span class="keywordflow">if</span> d &lt; 0:</div>
<div class="line">        md += u</div>
<div class="line">        me += q</div>
<div class="line">    <span class="keywordflow">if</span> e &lt; 0:</div>
<div class="line">        md += v</div>
<div class="line">        me += r</div>
<div class="line">    <span class="comment"># Compute bottom N bits of t*[d,e] + M*[md,me].</span></div>
<div class="line">    cd, ce = (u*d + v*e + md*M) % 2**N, (q*d + r*e + me*M) % 2**N</div>
<div class="line">    <span class="comment"># Correct md and me such that the bottom N bits of t*[d,e] + M*[md,me] are zero.</span></div>
<div class="line">    md -= (Mi * cd) % 2**N</div>
<div class="line">    me -= (Mi * ce) % 2**N</div>
<div class="line">    <span class="comment"># Do the full computation.</span></div>
<div class="line">    cd, ce = u*d + v*e + md*M, q*d + r*e + me*M</div>
<div class="line">    <span class="comment"># And cleanly divide by 2**N.</span></div>
<div class="line">    <span class="keywordflow">return</span> cd &gt;&gt; N, ce &gt;&gt; N</div>
</div><!-- fragment --><p>One last optimization: we can avoid the <em>md&thinsp;M</em> and <em>me&thinsp;M</em> multiplications in the bottom bits of <em>cd</em> and <em>ce</em> by moving them to the <em>md</em> and <em>me</em> correction:</p>
<div class="fragment"><div class="line">...</div>
<div class="line"><span class="comment"># Compute bottom N bits of t*[d,e].</span></div>
<div class="line">cd, ce = (u*d + v*e) % 2**N, (q*d + r*e) % 2**N</div>
<div class="line"><span class="comment"># Correct md and me such that the bottom N bits of t*[d,e]+M*[md,me] are zero.</span></div>
<div class="line"><span class="comment"># Note that this is not the same as {md = (-Mi * cd) % 2**N} etc. That would also result in N</span></div>
<div class="line"><span class="comment"># zero bottom bits, but isn&#39;t guaranteed to be a reduction of [0,2^N) compared to the</span></div>
<div class="line"><span class="comment"># previous md and me values, and thus would violate our bounds analysis.</span></div>
<div class="line">md -= (Mi*cd + md) % 2**N</div>
<div class="line">me -= (Mi*ce + me) % 2**N</div>
<div class="line">...</div>
</div><!-- fragment --><p>The resulting function takes <em>d</em> and <em>e</em> in range <em>(-2M,M)</em> as inputs, and outputs values in the same range. That also means that the <em>d</em> value at the end of <code>modinv</code> will be in that range, while we want a result in <em>[0,M)</em>. To do that, we need a normalization function. It's easy to integrate the conditional negation of <em>d</em> (based on the sign of <em>f</em>) into it as well:</p>
<div class="fragment"><div class="line"><span class="keyword">def </span><a class="code hl_function" href="normalize__prefix_8cpp.html#a359b1f30b0a9553a0e1ce551ddb7e9a6">normalize</a>(sign, v, M):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Compute sign*v mod M, where v is in range (-2*M,M); output in [0,M).&quot;&quot;&quot;</span></div>
<div class="line">    <span class="keyword">assert</span> sign == 1 <span class="keywordflow">or</span> sign == -1</div>
<div class="line">    <span class="comment"># v in (-2*M,M)</span></div>
<div class="line">    <span class="keywordflow">if</span> v &lt; 0:</div>
<div class="line">        v += M</div>
<div class="line">    <span class="comment"># v in (-M,M). Now multiply v with sign (which can only be 1 or -1).</span></div>
<div class="line">    <span class="keywordflow">if</span> sign == -1:</div>
<div class="line">        v = -v</div>
<div class="line">    <span class="comment"># v in (-M,M)</span></div>
<div class="line">    <span class="keywordflow">if</span> v &lt; 0:</div>
<div class="line">        v += M</div>
<div class="line">    <span class="comment"># v in [0,M)</span></div>
<div class="line">    <span class="keywordflow">return</span> v</div>
<div class="ttc" id="anormalize__prefix_8cpp_html_a359b1f30b0a9553a0e1ce551ddb7e9a6"><div class="ttname"><a href="normalize__prefix_8cpp.html#a359b1f30b0a9553a0e1ce551ddb7e9a6">normalize</a></div><div class="ttdeci">std::string normalize(const std::string &amp;line)</div><div class="ttdef"><b>Definition</b> <a href="normalize__prefix_8cpp_source.html#l00011">normalize_prefix.cpp:11</a></div></div>
</div><!-- fragment --><p>And calling it in <code>modinv</code> is simply:</p>
<div class="fragment"><div class="line">...</div>
<div class="line"><span class="keywordflow">return</span> <a class="code hl_function" href="normalize__prefix_8cpp.html#a359b1f30b0a9553a0e1ce551ddb7e9a6">normalize</a>(f, d, M)</div>
</div><!-- fragment --><h1>5. Constant-time operation</h1>
<p>The primary selling point of the algorithm is fast constant-time operation. What code flow still depends on the input data so far?</p>
<ul>
<li>the number of iterations of the while <em>g &ne; 0</em> loop in <code>modinv</code></li>
<li>the branches inside <code>divsteps_n_matrix</code></li>
<li>the sign checks in <code>update_de</code></li>
<li>the sign checks in <code>normalize</code></li>
</ul>
<p>To make the while loop in <code>modinv</code> constant time it can be replaced with a constant number of iterations. The paper proves (Theorem 11.2) that <em>741</em> divsteps are sufficient for any <em>256</em>-bit inputs, and <a href="https://github.com/sipa/safegcd-bounds">safegcd-bounds</a> shows that the slightly better bound <em>724</em> is sufficient even. Given that every loop iteration performs <em>N</em> divsteps, it will run a total of <em>&lceil;724/N&rceil;</em> times.</p>
<p>To deal with the branches in <code>divsteps_n_matrix</code> we will replace them with constant-time bitwise operations (and hope the C compiler isn't smart enough to turn them back into branches; see <code><a class="el" href="valgrind__ctime__test_8c.html">valgrind_ctime_test.c</a></code> for automated tests that this isn't the case). To do so, observe that a divstep can be written instead as (compare to the inner loop of <code>gcd</code> in section 1).</p>
<div class="fragment"><div class="line">x = -f <span class="keywordflow">if</span> delta &gt; 0 <span class="keywordflow">else</span> f         <span class="comment"># set x equal to (input) -f or f</span></div>
<div class="line"><span class="keywordflow">if</span> g &amp; 1:</div>
<div class="line">    g += x                         <span class="comment"># set g to (input) g-f or g+f</span></div>
<div class="line">    <span class="keywordflow">if</span> delta &gt; 0:</div>
<div class="line">        delta = -delta</div>
<div class="line">        f += g                     <span class="comment"># set f to (input) g (note that g was set to g-f before)</span></div>
<div class="line">delta += 1</div>
<div class="line">g &gt;&gt;= 1</div>
</div><!-- fragment --><p>To convert the above to bitwise operations, we rely on a trick to negate conditionally: per the definition of negative numbers in two's complement, (<em>-v == ~v + 1</em>) holds for every number <em>v</em>. As <em>-1</em> in two's complement is all <em>1</em> bits, bitflipping can be expressed as xor with <em>-1</em>. It follows that <em>-v == (v ^ -1) - (-1)</em>. Thus, if we have a variable <em>c</em> that takes on values <em>0</em> or <em>-1</em>, then <em>(v ^ c) - c</em> is <em>v</em> if <em>c=0</em> and <em>-v</em> if <em>c=-1</em>.</p>
<p>Using this we can write:</p>
<div class="fragment"><div class="line">x = -f <span class="keywordflow">if</span> delta &gt; 0 <span class="keywordflow">else</span> f</div>
</div><!-- fragment --><p>in constant-time form as:</p>
<div class="fragment"><div class="line">c1 = (-delta) &gt;&gt; 63</div>
<div class="line"><span class="comment"># Conditionally negate f based on c1:</span></div>
<div class="line">x = (f ^ c1) - c1</div>
</div><!-- fragment --><p>To use that trick, we need a helper mask variable <em>c1</em> that resolves the condition <em>&delta;&gt;0</em> to <em>-1</em> (if true) or <em>0</em> (if false). We compute <em>c1</em> using right shifting, which is equivalent to dividing by the specified power of <em>2</em> and rounding down (in Python, and also in C under the assumption of a typical two's complement system; see <code><a class="el" href="assumptions_8h.html">assumptions.h</a></code> for tests that this is the case). Right shifting by <em>63</em> thus maps all numbers in range *[-2<sup>63</sup>,0)* to <em>-1</em>, and numbers in range *[0,2<sup>63</sup>)* to <em>0</em>.</p>
<p>Using the facts that <em>x&amp;0=0</em> and <em>x&amp;(-1)=x</em> (on two's complement systems again), we can write:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> g &amp; 1:</div>
<div class="line">    g += x</div>
</div><!-- fragment --><p>as:</p>
<div class="fragment"><div class="line"><span class="comment"># Compute c2=0 if g is even and c2=-1 if g is odd.</span></div>
<div class="line">c2 = -(g &amp; 1)</div>
<div class="line"><span class="comment"># This masks out x if g is even, and leaves x be if g is odd.</span></div>
<div class="line">g += x &amp; c2</div>
</div><!-- fragment --><p>Using the conditional negation trick again we can write:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> g &amp; 1:</div>
<div class="line">    <span class="keywordflow">if</span> delta &gt; 0:</div>
<div class="line">        delta = -delta</div>
</div><!-- fragment --><p>as:</p>
<div class="fragment"><div class="line"><span class="comment"># Compute c3=-1 if g is odd and delta&gt;0, and 0 otherwise.</span></div>
<div class="line">c3 = c1 &amp; c2</div>
<div class="line"><span class="comment"># Conditionally negate delta based on c3:</span></div>
<div class="line">delta = (delta ^ c3) - c3</div>
</div><!-- fragment --><p>Finally:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> g &amp; 1:</div>
<div class="line">    <span class="keywordflow">if</span> delta &gt; 0:</div>
<div class="line">        f += g</div>
</div><!-- fragment --><p>becomes:</p>
<div class="fragment"><div class="line">f += g &amp; c3</div>
</div><!-- fragment --><p>It turns out that this can be implemented more efficiently by applying the substitution <em>&eta;=-&delta;</em>. In this representation, negating <em>&delta;</em> corresponds to negating <em>&eta;</em>, and incrementing <em>&delta;</em> corresponds to decrementing <em>&eta;</em>. This allows us to remove the negation in the <em>c1</em> computation:</p>
<div class="fragment"><div class="line"><span class="comment"># Compute a mask c1 for eta &lt; 0, and compute the conditional negation x of f:</span></div>
<div class="line">c1 = eta &gt;&gt; 63</div>
<div class="line">x = (f ^ c1) - c1</div>
<div class="line"><span class="comment"># Compute a mask c2 for odd g, and conditionally add x to g:</span></div>
<div class="line">c2 = -(g &amp; 1)</div>
<div class="line">g += x &amp; c2</div>
<div class="line"><span class="comment"># Compute a mask c for (eta &lt; 0) and odd (input) g, and use it to conditionally negate eta,</span></div>
<div class="line"><span class="comment"># and add g to f:</span></div>
<div class="line">c3 = c1 &amp; c2</div>
<div class="line">eta = (eta ^ c3) - c3</div>
<div class="line">f += g &amp; c3</div>
<div class="line"><span class="comment"># Incrementing delta corresponds to decrementing eta.</span></div>
<div class="line">eta -= 1</div>
<div class="line">g &gt;&gt;= 1</div>
</div><!-- fragment --><p><a class="el" href="struct_a.html">A</a> variant of divsteps with better worst-case performance can be used instead: starting <em>&delta;</em> at <em>1/2</em> instead of <em>1</em>. This reduces the worst case number of iterations to <em>590</em> for <em>256</em>-bit inputs (which can be shown using convex hull analysis). In this case, the substitution <em>&zeta;=-(&delta;+1/2)</em> is used instead to keep the variable integral. Incrementing <em>&delta;</em> by <em>1</em> still translates to decrementing <em>&zeta;</em> by <em>1</em>, but negating <em>&delta;</em> now corresponds to going from <em>&zeta;</em> to <em>-(&zeta;+1)</em>, or *~&zeta;<em>. Doing that conditionally based on *c3</em> is simply:</p>
<div class="fragment"><div class="line">...</div>
<div class="line">c3 = c1 &amp; c2</div>
<div class="line">zeta ^= c3</div>
<div class="line">...</div>
</div><!-- fragment --><p>By replacing the loop in <code>divsteps_n_matrix</code> with a variant of the divstep code above (extended to also apply all <em>f</em> operations to <em>u</em>, <em>v</em> and all <em>g</em> operations to <em>q</em>, <em>r</em>), a constant-time version of <code>divsteps_n_matrix</code> is obtained. The full code will be in section 7.</p>
<p>These bit fiddling tricks can also be used to make the conditional negations and additions in <code>update_de</code> and <code>normalize</code> constant-time.</p>
<h1>6. Variable-time optimizations</h1>
<p>In section 5, we modified the <code>divsteps_n_matrix</code> function (and a few others) to be constant time. Constant time operations are only necessary when computing modular inverses of secret data. In other cases, it slows down calculations unnecessarily. In this section, we will construct a faster non-constant time <code>divsteps_n_matrix</code> function.</p>
<p>To do so, first consider yet another way of writing the inner loop of divstep operations in <code>gcd</code> from section 1. This decomposition is also explained in the paper in section 8.2. We use the original version with initial <em>&delta;=1</em> and <em>&eta;=-&delta;</em> here.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> _ <span class="keywordflow">in</span> range(N):</div>
<div class="line">    <span class="keywordflow">if</span> g &amp; 1 <span class="keywordflow">and</span> eta &lt; 0:</div>
<div class="line">        eta, f, g = -eta, g, -f</div>
<div class="line">    <span class="keywordflow">if</span> g &amp; 1:</div>
<div class="line">        g += f</div>
<div class="line">    eta -= 1</div>
<div class="line">    g &gt;&gt;= 1</div>
</div><!-- fragment --><p>Whenever <em>g</em> is even, the loop only shifts <em>g</em> down and decreases <em>&eta;</em>. When <em>g</em> ends in multiple zero bits, these iterations can be consolidated into one step. This requires counting the bottom zero bits efficiently, which is possible on most platforms; it is abstracted here as the function <code>count_trailing_zeros</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">def </span>count_trailing_zeros(v):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">    When v is zero, consider all N zero bits as &quot;trailing&quot;.</span></div>
<div class="line"><span class="stringliteral">    For a non-zero value v, find z such that v=(d&lt;&lt;z) for some odd d.</span></div>
<div class="line"><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line">    <span class="keywordflow">if</span> v == 0:</div>
<div class="line">        <span class="keywordflow">return</span> N</div>
<div class="line">    <span class="keywordflow">else</span>:</div>
<div class="line">        <span class="keywordflow">return</span> (v &amp; -v).bit_length() - 1</div>
<div class="line"> </div>
<div class="line">i = N <span class="comment"># divsteps left to do</span></div>
<div class="line"><span class="keywordflow">while</span> <span class="keyword">True</span>:</div>
<div class="line">    <span class="comment"># Get rid of all bottom zeros at once. In the first iteration, g may be odd and the following</span></div>
<div class="line">    <span class="comment"># lines have no effect (until &quot;if eta &lt; 0&quot;).</span></div>
<div class="line">    zeros = min(i, count_trailing_zeros(g))</div>
<div class="line">    eta -= zeros</div>
<div class="line">    g &gt;&gt;= zeros</div>
<div class="line">    i -= zeros</div>
<div class="line">    <span class="keywordflow">if</span> i == 0:</div>
<div class="line">        <span class="keywordflow">break</span></div>
<div class="line">    <span class="comment"># We know g is odd now</span></div>
<div class="line">    <span class="keywordflow">if</span> eta &lt; 0:</div>
<div class="line">        eta, f, g = -eta, g, -f</div>
<div class="line">    g += f</div>
<div class="line">    <span class="comment"># g is even now, and the eta decrement and g shift will happen in the next loop.</span></div>
</div><!-- fragment --><p>We can now remove multiple bottom <em>0</em> bits from <em>g</em> at once, but still need a full iteration whenever there is a bottom <em>1</em> bit. In what follows, we will get rid of multiple <em>1</em> bits simultaneously as well.</p>
<p>Observe that as long as <em>&eta; &amp;geq; 0</em>, the loop does not modify <em>f</em>. Instead, it cancels out bottom bits of <em>g</em> and shifts them out, and decreases <em>&eta;</em> and <em>i</em> accordingly - interrupting only when <em>&eta;</em> becomes negative, or when <em>i</em> reaches <em>0</em>. Combined, this is equivalent to adding a multiple of <em>f</em> to <em>g</em> to cancel out multiple bottom bits, and then shifting them out.</p>
<p>It is easy to find what that multiple is: we want a number <em>w</em> such that <em>g+w&thinsp;f</em> has a few bottom zero bits. If that number of bits is <em>L</em>, we want *g+w&thinsp;f mod 2<sup>L</sup> = 0*, or *w = -g/f mod 2<sup>L</sup><em>. Since *f</em> is odd, such a <em>w</em> exists for any <em>L</em>. <em>L</em> cannot be more than <em>i</em> steps (as we'd finish the loop before doing more) or more than <em>&eta;+1</em> steps (as we'd run <code>eta, f, g = -eta, g, -f</code> at that point), but apart from that, we're only limited by the complexity of computing <em>w</em>.</p>
<p>This code demonstrates how to cancel up to 4 bits per step:</p>
<div class="fragment"><div class="line">NEGINV16 = [15, 5, 3, 9, 7, 13, 11, 1] <span class="comment"># NEGINV16[n//2] = (-n)^-1 mod 16, for odd n</span></div>
<div class="line">i = N</div>
<div class="line"><span class="keywordflow">while</span> <span class="keyword">True</span>:</div>
<div class="line">    zeros = min(i, count_trailing_zeros(g))</div>
<div class="line">    eta -= zeros</div>
<div class="line">    g &gt;&gt;= zeros</div>
<div class="line">    i -= zeros</div>
<div class="line">    <span class="keywordflow">if</span> i == 0:</div>
<div class="line">        <span class="keywordflow">break</span></div>
<div class="line">    <span class="comment"># We know g is odd now</span></div>
<div class="line">    <span class="keywordflow">if</span> eta &lt; 0:</div>
<div class="line">        eta, f, g = -eta, g, -f</div>
<div class="line">    <span class="comment"># Compute limit on number of bits to cancel</span></div>
<div class="line">    limit = min(min(eta + 1, i), 4)</div>
<div class="line">    <span class="comment"># Compute w = -g/f mod 2**limit, using the table value for -1/f mod 2**4. Note that f is</span></div>
<div class="line">    <span class="comment"># always odd, so its inverse modulo a power of two always exists.</span></div>
<div class="line">    w = (g * NEGINV16[(f &amp; 15) // 2]) % (2**limit)</div>
<div class="line">    <span class="comment"># As w = -g/f mod (2**limit), g+w*f mod 2**limit = 0 mod 2**limit.</span></div>
<div class="line">    g += w * f</div>
<div class="line">    <span class="keyword">assert</span> g % (2**limit) == 0</div>
<div class="line">    <span class="comment"># The next iteration will now shift out at least limit bottom zero bits from g.</span></div>
</div><!-- fragment --><p>By using a bigger table more bits can be cancelled at once. The table can also be implemented as a formula. Several formulas are known for computing modular inverses modulo powers of two; some can be found in Hacker's Delight second edition by Henry <a class="el" href="struct_s.html">S</a>. Warren, Jr. pages 245-247. Here we need the negated modular inverse, which is a simple transformation of those:</p>
<ul>
<li>Instead of a 3-bit table:<ul>
<li><em>-f</em> or <em>f ^ 6</em></li>
</ul>
</li>
<li>Instead of a 4-bit table:<ul>
<li><em>1 - f(f + 1)</em></li>
<li><em>-(f + (((f + 1) &amp; 4) &lt;&lt; 1))</em></li>
</ul>
</li>
<li>For larger tables the following technique can be used: if *w=-1/f mod 2<sup>L</sup><em>, then *w(w&thinsp;f+2)</em> is *-1/f mod 2<sup>2L</sup>*. This allows extending the previous formulas (or tables). In particular we have this 6-bit function (based on the 3-bit function above):<ul>
<li>*f(f<sup>2</sup> - 2)*</li>
</ul>
</li>
</ul>
<p>This loop, again extended to also handle <em>u</em>, <em>v</em>, <em>q</em>, and <em>r</em> alongside <em>f</em> and <em>g</em>, placed in <code>divsteps_n_matrix</code>, gives a significantly faster, but non-constant time version.</p>
<h1>7. Final Python version</h1>
<p>All together we need the following functions:</p>
<ul>
<li><a class="el" href="struct_a.html">A</a> way to compute the transition matrix in constant time, using the <code>divsteps_n_matrix</code> function from section 2, but with its loop replaced by a variant of the constant-time divstep from section 5, extended to handle <em>u</em>, <em>v</em>, <em>q</em>, <em>r</em>:</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">def </span>divsteps_n_matrix(zeta, f, g):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Compute zeta and transition matrix t after N divsteps (multiplied by 2^N).&quot;&quot;&quot;</span></div>
<div class="line">    u, v, q, r = 1, 0, 0, 1 <span class="comment"># start with identity matrix</span></div>
<div class="line">    <span class="keywordflow">for</span> _ <span class="keywordflow">in</span> range(N):</div>
<div class="line">        c1 = zeta &gt;&gt; 63</div>
<div class="line">        <span class="comment"># Compute x, y, z as conditionally-negated versions of f, u, v.</span></div>
<div class="line">        x, y, z = (f ^ c1) - c1, (u ^ c1) - c1, (v ^ c1) - c1</div>
<div class="line">        c2 = -(g &amp; 1)</div>
<div class="line">        <span class="comment"># Conditionally add x, y, z to g, q, r.</span></div>
<div class="line">        g, q, r = g + (x &amp; c2), q + (y &amp; c2), r + (z &amp; c2)</div>
<div class="line">        c1 &amp;= c2                     <span class="comment"># reusing c1 here for the earlier c3 variable</span></div>
<div class="line">        zeta = (zeta ^ c1) - 1       <span class="comment"># inlining the unconditional zeta decrement here</span></div>
<div class="line">        <span class="comment"># Conditionally add g, q, r to f, u, v.</span></div>
<div class="line">        f, u, v = f + (g &amp; c1), u + (q &amp; c1), v + (r &amp; c1)</div>
<div class="line">        <span class="comment"># When shifting g down, don&#39;t shift q, r, as we construct a transition matrix multiplied</span></div>
<div class="line">        <span class="comment"># by 2^N. Instead, shift f&#39;s coefficients u and v up.</span></div>
<div class="line">        g, u, v = g &gt;&gt; 1, u &lt;&lt; 1, v &lt;&lt; 1</div>
<div class="line">    <span class="keywordflow">return</span> zeta, (u, v, q, r)</div>
</div><!-- fragment --><ul>
<li>The functions to update <em>f</em> and <em>g</em>, and <em>d</em> and <em>e</em>, from section 2 and section 4, with the constant-time changes to <code>update_de</code> from section 5:</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">def </span>update_fg(f, g, t):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Multiply matrix t/2^N with [f, g].&quot;&quot;&quot;</span></div>
<div class="line">    u, v, q, r = t</div>
<div class="line">    cf, cg = u*f + v*g, q*f + r*g</div>
<div class="line">    <span class="keywordflow">return</span> cf &gt;&gt; N, cg &gt;&gt; N</div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>update_de(d, e, t, M, Mi):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Multiply matrix t/2^N with [d, e], modulo M.&quot;&quot;&quot;</span></div>
<div class="line">    u, v, q, r = t</div>
<div class="line">    d_sign, e_sign = d &gt;&gt; 257, e &gt;&gt; 257</div>
<div class="line">    md, me = (u &amp; d_sign) + (v &amp; e_sign), (q &amp; d_sign) + (r &amp; e_sign)</div>
<div class="line">    cd, ce = (u*d + v*e) % 2**N, (q*d + r*e) % 2**N</div>
<div class="line">    md -= (Mi*cd + md) % 2**N</div>
<div class="line">    me -= (Mi*ce + me) % 2**N</div>
<div class="line">    cd, ce = u*d + v*e + M*md, q*d + r*e + M*me</div>
<div class="line">    <span class="keywordflow">return</span> cd &gt;&gt; N, ce &gt;&gt; N</div>
</div><!-- fragment --><ul>
<li>The <code>normalize</code> function from section 4, made constant time as well:</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">def </span><a class="code hl_function" href="normalize__prefix_8cpp.html#a359b1f30b0a9553a0e1ce551ddb7e9a6">normalize</a>(sign, v, M):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Compute sign*v mod M, where v in (-2*M,M); output in [0,M).&quot;&quot;&quot;</span></div>
<div class="line">    v_sign = v &gt;&gt; 257</div>
<div class="line">    <span class="comment"># Conditionally add M to v.</span></div>
<div class="line">    v += M &amp; v_sign</div>
<div class="line">    c = (sign - 1) &gt;&gt; 1</div>
<div class="line">    <span class="comment"># Conditionally negate v.</span></div>
<div class="line">    v = (v ^ c) - c</div>
<div class="line">    v_sign = v &gt;&gt; 257</div>
<div class="line">    <span class="comment"># Conditionally add M to v again.</span></div>
<div class="line">    v += M &amp; v_sign</div>
<div class="line">    <span class="keywordflow">return</span> v</div>
</div><!-- fragment --><ul>
<li>And finally the <code>modinv</code> function too, adapted to use <em>&zeta;</em> instead of <em>&delta;</em>, and using the fixed iteration count from section 5:</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">def </span>modinv(M, Mi, x):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Compute the modular inverse of x mod M, given Mi=1/M mod 2^N.&quot;&quot;&quot;</span></div>
<div class="line">    zeta, f, g, d, e = -1, M, x, 0, 1</div>
<div class="line">    <span class="keywordflow">for</span> _ <span class="keywordflow">in</span> range((590 + N - 1) // N):</div>
<div class="line">        zeta, t = divsteps_n_matrix(zeta, f % 2**N, g % 2**N)</div>
<div class="line">        f, g = update_fg(f, g, t)</div>
<div class="line">        d, e = update_de(d, e, t, M, Mi)</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_function" href="normalize__prefix_8cpp.html#a359b1f30b0a9553a0e1ce551ddb7e9a6">normalize</a>(f, d, M)</div>
</div><!-- fragment --><ul>
<li>To get a variable time version, replace the <code>divsteps_n_matrix</code> function with one that uses the divsteps loop from section 5, and a <code>modinv</code> version that calls it without the fixed iteration count:</li>
</ul>
<div class="fragment"><div class="line">NEGINV16 = [15, 5, 3, 9, 7, 13, 11, 1] <span class="comment"># NEGINV16[n//2] = (-n)^-1 mod 16, for odd n</span></div>
<div class="line"><span class="keyword">def </span>divsteps_n_matrix_var(eta, f, g):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Compute eta and transition matrix t after N divsteps (multiplied by 2^N).&quot;&quot;&quot;</span></div>
<div class="line">    u, v, q, r = 1, 0, 0, 1</div>
<div class="line">    i = N</div>
<div class="line">    <span class="keywordflow">while</span> <span class="keyword">True</span>:</div>
<div class="line">        zeros = min(i, count_trailing_zeros(g))</div>
<div class="line">        eta, i = eta - zeros, i - zeros</div>
<div class="line">        g, u, v = g &gt;&gt; zeros, u &lt;&lt; zeros, v &lt;&lt; zeros</div>
<div class="line">        <span class="keywordflow">if</span> i == 0:</div>
<div class="line">            <span class="keywordflow">break</span></div>
<div class="line">        <span class="keywordflow">if</span> eta &lt; 0:</div>
<div class="line">            eta, f, u, v, g, q, r = -eta, g, q, r, -f, -u, -v</div>
<div class="line">        limit = min(min(eta + 1, i), 4)</div>
<div class="line">        w = (g * NEGINV16[(f &amp; 15) // 2]) % (2**limit)</div>
<div class="line">        g, q, r = g + w*f, q + w*u, r + w*v</div>
<div class="line">    <span class="keywordflow">return</span> eta, (u, v, q, r)</div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>modinv_var(M, Mi, x):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Compute the modular inverse of x mod M, given Mi = 1/M mod 2^N.&quot;&quot;&quot;</span></div>
<div class="line">    eta, f, g, d, e = -1, M, x, 0, 1</div>
<div class="line">    <span class="keywordflow">while</span> g != 0:</div>
<div class="line">        eta, t = divsteps_n_matrix_var(eta, f % 2**N, g % 2**N)</div>
<div class="line">        f, g = update_fg(f, g, t)</div>
<div class="line">        d, e = update_de(d, e, t, M, Mi)</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_function" href="normalize__prefix_8cpp.html#a359b1f30b0a9553a0e1ce551ddb7e9a6">normalize</a>(f, d, Mi)</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
